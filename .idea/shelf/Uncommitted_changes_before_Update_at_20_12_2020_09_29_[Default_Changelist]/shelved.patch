Index: src/gameClient/Pokemon.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package gameClient;\r\n\r\nimport api.NodeData;\r\nimport api.edgeData;\r\nimport api.geo_location;\r\nimport org.json.JSONArray;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\npublic class Pokemon {\r\n    private double value;\r\n    private int type;\r\n    private geo_location pos;\r\n    int src;\r\n    int dest;\r\n    private edgeData.edgeLocation EL;\r\n    Agent agent;\r\n    boolean isLogin;\r\n\r\n    public Pokemon(double value, int type, geo_location pos)\r\n    {\r\n        this.value=value;\r\n        this.type=type;\r\n        this.pos=pos;\r\n        this.EL=null;\r\n        agent=null;\r\n        isLogin=false;\r\n    }\r\n\r\n    public double getValue() {\r\n        return value;\r\n    }\r\n\r\n    public void setValue(double value) {\r\n        this.value = value;\r\n    }\r\n\r\n    public int getType() {\r\n        return type;\r\n    }\r\n\r\n    public void setType(int type) {\r\n        this.type = type;\r\n    }\r\n\r\n    public geo_location getPos() {\r\n        return pos;\r\n    }\r\n\r\n    public void setPos(geo_location pos) {\r\n        this.pos = pos;\r\n    }\r\n\r\n    public int getSrc() {\r\n        return src;\r\n    }\r\n\r\n    public void setSrc(int src) {\r\n        this.src = src;\r\n    }\r\n\r\n    public int getDest() {\r\n        return dest;\r\n    }\r\n\r\n    public void setDest(int dest) {\r\n        this.dest = dest;\r\n    }\r\n    public void setEL(edgeData.edgeLocation el)\r\n    {\r\n        EL=el;\r\n    }\r\n    public edgeData.edgeLocation getEL()\r\n    {\r\n        return EL;\r\n    }\r\n\r\n\r\n    //Create pokemon from JSON Object\r\n    public Pokemon(JSONObject pokObj) throws JSONException {\r\n        this.value=pokObj.getDouble(\"value\");\r\n        this.type= pokObj.getInt(\"type\");\r\n        String pos = pokObj.getString(\"pos\");\r\n        String[] locST = pos.split(\",\", 3);\r\n        Double[] geoL = new Double[3];\r\n        for (int j = 0; j < locST.length; j++)\r\n            geoL[j] = Double.parseDouble(locST[j]);\r\n        geo_location location = new NodeData.geoLocation(geoL[0], geoL[1], geoL[2]);\r\n        this.pos=location;\r\n        agent=null;\r\n    }\r\n\r\n    public boolean is_in_the_game(String poksInTheGame, Pokemon pok) throws JSONException {\r\n        JSONObject newPokemonsObj = new JSONObject(poksInTheGame);\r\n        JSONArray pokemonsArr = newPokemonsObj.getJSONArray(\"Pokemons\");\r\n        boolean ans = false;\r\n        for (int i = 0; i < pokemonsArr.length(); i++) {\r\n            Pokemon newPok = new Pokemon(pokemonsArr.getJSONObject(i).getJSONObject(\"Pokemon\"));\r\n            if (pok.getPos().distance(newPok.getPos()) < 0.000001) {\r\n                ans = true;\r\n                break;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public void setLogin(boolean b)\r\n    {\r\n        this.isLogin=b;\r\n    }\r\n    public boolean getLogin()\r\n    {\r\n        return isLogin;\r\n    }\r\n    public void setAgent(Agent agent) {\r\n        this.agent = agent;\r\n    }\r\n\r\n    public Agent getAgent(){\r\n        return agent;\r\n    }\r\n    public String toString()\r\n    {\r\n        String s;\r\n        s=\"<value: \"+value+\", type: \"+type+\", src: \"+src+\", dest: \"+dest+\" agent: \";\r\n        if (agent!=null)\r\n            return s+agent.getId()+\" src: (\"+agent.getSrc()+\", \"+agent.getDest()+\") >\\n\";\r\n        else\r\n            return s+\"non>\\n\";\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/gameClient/Pokemon.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ src/gameClient/Pokemon.java	(date 1608414343856)
@@ -90,9 +90,9 @@
         agent=null;
     }
 
-    public boolean is_in_the_game(String poksInTheGame, Pokemon pok) throws JSONException {
-        JSONObject newPokemonsObj = new JSONObject(poksInTheGame);
-        JSONArray pokemonsArr = newPokemonsObj.getJSONArray("Pokemons");
+        public boolean is_in_the_game(String poksInTheGame, Pokemon pok) throws JSONException {
+            JSONObject newPokemonsObj = new JSONObject(poksInTheGame);
+            JSONArray pokemonsArr = newPokemonsObj.getJSONArray("Pokemons");
         boolean ans = false;
         for (int i = 0; i < pokemonsArr.length(); i++) {
             Pokemon newPok = new Pokemon(pokemonsArr.getJSONObject(i).getJSONObject("Pokemon"));
Index: src/gameClient/LoginFrame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package gameClient;\r\n\r\n\r\nimport javax.sound.sampled.Clip;\r\nimport javax.sound.sampled.LineUnavailableException;\r\nimport javax.sound.sampled.UnsupportedAudioFileException;\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\nimport java.io.IOException;\r\n\r\npublic class LoginFrame extends JFrame implements ActionListener {\r\n    private JTextField ID_Text;\r\n    private JLabel ID_Label;\r\n    private JLabel GameNumber_Label;\r\n\r\n    private JPanel panel;\r\n    private JComboBox GameOpt;\r\n    private JButton LoginButton;\r\n    private JButton Mute;\r\n    private JButton unMute;\r\n    private JLabel text;\r\n    private int Mark;\r\n    private int countMark;\r\n    private int ID;\r\n    private int GameNumber;\r\n    private int h = 350;\r\n    private int w = 550;\r\n    private ImageIcon pokemon;\r\n    private Image image;\r\n    private Graphics gr;\r\n    private JLabel back;\r\n    private Clip clip;\r\n\r\n    public LoginFrame() throws UnsupportedAudioFileException, IOException, LineUnavailableException {\r\n        setSize(w, h);\r\n        init();\r\n        this.revalidate();\r\n        panel.revalidate();\r\n    }\r\n\r\n    public void init() throws UnsupportedAudioFileException, IOException, LineUnavailableException {\r\n        countMark=0;\r\n        w = getWidth();\r\n        h = getHeight();\r\n        this.setVisible(true);\r\n        this.setResizable(false);\r\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        panel = new JPanel();\r\n        this.revalidate();\r\n        panel.revalidate();\r\n        panel.setLayout(null);\r\n        back = new JLabel();\r\n        setID();\r\n        setGameNumber();\r\n        setButtons();\r\n        setPanel();\r\n        this.add(panel);\r\n        //playMusic();\r\n    }\r\n\r\n    public void paint(Graphics g) {\r\n        w = getWidth();\r\n        h = getHeight();\r\n        this.setSize(w, h);\r\n        image = this.createImage(w, h);\r\n        gr = image.getGraphics();\r\n        paintComponents(gr);\r\n        g.drawImage(image, 0, 0, this);\r\n        back.setBounds(0, 0, getWidth(), getHeight());\r\n    }\r\n\r\n    private void setID() {\r\n        ID_Label = new JLabel(\"ID number\");\r\n        Font f1 = new Font(\"SansSerif\", Font.BOLD, 15);\r\n        Font f2 = new Font(\"SansSerif\", Font.PLAIN, 12);\r\n        ID_Label.setFont(f1);\r\n        ID_Label.setBounds(175, 40, 200, 20);\r\n        ID_Text = new JTextField(20);\r\n        ID_Text.setFont(f2);\r\n        ID_Text.setBounds(175, 70, 200, 28);\r\n    }\r\n\r\n    private void setGameNumber() {\r\n        Font f1 = new Font(\"SansSerif\", Font.BOLD, 15);\r\n        Font f2 = new Font(\"SansSerif\", Font.PLAIN, 12);\r\n        GameNumber_Label = new JLabel(\"Game number\");\r\n        GameNumber_Label.setFont(f1);\r\n        GameNumber_Label.setBounds(175, 120, 200, 20);\r\n        String[] s={\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\",\r\n                \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"10\", \"21\", \"22\", \"23\"};\r\n        GameOpt=new JComboBox(s);\r\n        GameOpt.setBackground(Color.white);\r\n        GameOpt.setFont(f2);\r\n        GameOpt.setBounds(175, 150, 200, 28);\r\n    }\r\n\r\n    private void setButtons() {\r\n        //login button\r\n        LoginButton = new JButton(\"login\");\r\n        LoginButton.setVisible(true);\r\n        Font f3 = new Font(\"Dialog\", Font.BOLD, 15);\r\n        LoginButton.setBackground(new Color(217, 89, 64));\r\n        LoginButton.setFont(f3);\r\n        LoginButton.setBounds(225, 250, 100, 25);\r\n        LoginButton.addActionListener(this);\r\n    }\r\n\r\n    private void setPanel() {\r\n        panel.add(GameNumber_Label);\r\n        panel.add(ID_Label);\r\n        panel.add(ID_Text);\r\n        panel.add(LoginButton);\r\n        panel.add(GameOpt);\r\n        // panel.add(Mute);\r\n        //panel.add(unMute);\r\n        panel.add(back);\r\n        panel.setSize(getWidth(), getHeight());\r\n    }\r\n\r\n    public void paintComponents(Graphics g) {\r\n        super.paintComponents(g);\r\n        pokemon = new ImageIcon(\"src//gameClient//files//ash.jpg\");\r\n        Image pokemon1 = pokemon.getImage();\r\n        Image pokemon2 = pokemon1.getScaledInstance(getWidth(), getHeight(), Image.SCALE_DEFAULT);\r\n        pokemon = new ImageIcon(pokemon2);\r\n        back.setIcon(pokemon);\r\n    }\r\n\r\n    @Override\r\n    public void actionPerformed(ActionEvent e) {\r\n        if ((e.getSource())==LoginButton) {\r\n            try {\r\n                ID = Integer.parseInt(ID_Text.getText());\r\n                System.out.println(\"ID: \"+ID);\r\n                GameNumber = GameOpt.getSelectedIndex();\r\n                System.out.println(\"game number: \"+GameNumber);\r\n                JOptionPane.showMessageDialog(this, \"Let's start the game\");\r\n                run();\r\n                // clip.stop();\r\n                //EX22.ex2.run();\r\n\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n                JOptionPane.showMessageDialog(this, \"Invalid ID\\nPlease enter again\");\r\n                System.out.println(\"ERROR, enter again\");\r\n            }\r\n        }\r\n        if(e.getSource()==unMute) {\r\n            unMute.setVisible(false);\r\n            Mute.setVisible(true);\r\n        }\r\n        if(e.getSource()==Mute) {\r\n            unMute.setVisible(true);\r\n            Mute.setVisible(false);\r\n        }\r\n    }\r\n\r\n\r\n//    public void playMusic() throws IOException, LineUnavailableException, UnsupportedAudioFileException {\r\n//        File musicPath = new File(\"src/gameClient/files/pokemon_song.wav\");\r\n//        AudioInputStream audioInput = AudioSystem.getAudioInputStream(musicPath);\r\n//        clip = AudioSystem.getClip();\r\n//        clip.open(audioInput);\r\n//        clip.start();\r\n//    }\r\n\r\n    public void run() {\r\n        Ex2 ex2=new Ex2();\r\n        ex2.setID(ID);\r\n        ex2.setGameNumber(GameNumber);\r\n        this.dispose();\r\n        Thread Game = new Thread(ex2);\r\n        Game.start();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/gameClient/LoginFrame.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ src/gameClient/LoginFrame.java	(date 1608448724144)
@@ -121,7 +121,7 @@
 
     public void paintComponents(Graphics g) {
         super.paintComponents(g);
-        pokemon = new ImageIcon("src//gameClient//files//ash.jpg");
+        pokemon = new ImageIcon("data//images//ash.jpg");
         Image pokemon1 = pokemon.getImage();
         Image pokemon2 = pokemon1.getScaledInstance(getWidth(), getHeight(), Image.SCALE_DEFAULT);
         pokemon = new ImageIcon(pokemon2);
@@ -139,7 +139,6 @@
                 JOptionPane.showMessageDialog(this, "Let's start the game");
                 run();
                 // clip.stop();
-                //EX22.ex2.run();
 
             } catch (Exception ex) {
                 ex.printStackTrace();
@@ -157,7 +156,6 @@
         }
     }
 
-
 //    public void playMusic() throws IOException, LineUnavailableException, UnsupportedAudioFileException {
 //        File musicPath = new File("src/gameClient/files/pokemon_song.wav");
 //        AudioInputStream audioInput = AudioSystem.getAudioInputStream(musicPath);
Index: src/gameClient/GameFrame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package gameClient;\r\n\r\n\r\nimport api.directed_weighted_graph;\r\nimport api.edge_data;\r\nimport api.geo_location;\r\nimport api.node_data;\r\nimport gameClient.util.Point3D;\r\nimport gameClient.util.Range;\r\nimport gameClient.util.Range2D;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.*;\r\nimport java.awt.geom.Rectangle2D;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class GameFrame extends JFrame {\r\n    private int _ind;\r\n    public GameData _ar;\r\n    private ImageIcon pokemon;\r\n    private ImageIcon agent;\r\n    private JPanel panel;\r\n    private JLabel TimeToEnd;\r\n    private JLabel TotalValue;\r\n    private JLabel GameLevel;\r\n    //private JLabel TimeToEnd;\r\n    private gameClient.util.Range2Range _w2f;\r\n\r\n\r\n    public GameFrame(String a) {\r\n        super(a);\r\n        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n        this.setVisible(true);\r\n        panel =new JPanel();\r\n        this.add(panel);\r\n//        TimeToEnd=new JLabel();\r\n//        TotalValue=new JLabel();\r\n//        GameLevel=new JLabel();\r\n        int _ind = 0;\r\n    }\r\n    public void update(GameData ar) {\r\n        this._ar = ar;\r\n        updateFrame();\r\n    }\r\n    private void updateFrame() {\r\n        double h=this.getHeight(), w=this.getWidth();\r\n        Range rx = new Range(0.06*w,w-0.06*w);\r\n        Range ry = new Range(h-0.08*h,0.30*h);\r\n        Range2D frame = new Range2D(rx,ry);\r\n        directed_weighted_graph g = _ar.getGraph();\r\n        _w2f = GameData.w2f(g,frame);\r\n    }\r\n\r\n    public void paint(Graphics g) {\r\n        int w = this.getWidth();\r\n        int h = this.getHeight();\r\n        setSize(w,h);\r\n        updateFrame();\r\n        Image buffer_image;\r\n        Graphics buffer_graphics;\r\n        buffer_image = createImage(w, h);\r\n        buffer_graphics = buffer_image.getGraphics();\r\n        buffer_graphics.clearRect(0, 0, w, h);\r\n        drawGraph(buffer_graphics);\r\n        drawPokemons(buffer_graphics);\r\n        drawAgants(buffer_graphics);\r\n        drawInfo(buffer_graphics);\r\n        g.drawImage(buffer_image, 0, 0, this);\r\n    }\r\n\r\n    private void drawInfo(Graphics g) {\r\n        List<String> str = _ar.get_info();\r\n        double w=getWidth(), h=0.22*getHeight();\r\n        int size=(int)((0.07)*((w+h)/2));\r\n        if(w>700)\r\n            size=30;\r\n        Font f=new Font(\"SansSerif\", Font.BOLD, size);\r\n        g.setFont(f);\r\n        g.setColor(Color.BLACK);\r\n        double w1=getWidth(\"Level: \"+str.get(0), g, f)[0];\r\n        double w2=getWidth(\"Score: \",g,f)[0];\r\n        double w3=getWidth(\"Time left: \",g,f)[0];\r\n        double w4=getWidth(str.get(1),g,f)[0];\r\n        double h1=getWidth(\"Level: \"+str.get(0), g, f)[1];\r\n        g.fillRect(0,0,(int)(w), (int)(h));\r\n        g.setColor(new Color(221,183, 63 ));\r\n        g.fillRect(0,(int)(h)-2,(int)(w),4);\r\n        g.drawString(\"Level: \"+str.get(0), (int)(0.5*w-0.5*w1), (int)(h*0.49));\r\n        double x=(w-(2.5*w2+w3+w4))/2;\r\n        g.drawString(\"Score: \"+str.get(2), (int)(x) ,(int)(0.58*h+h1));\r\n        int time=Integer.parseInt(str.get(1));\r\n        x+=2.5*w2;\r\n        g.drawString(\"Time left: \",(int)(x) ,(int)(0.58*h+h1));\r\n        x+=w3;\r\n        if(time<6)\r\n        {\r\n            g.setColor(Color.red);\r\n            g.drawString(str.get(1),(int)(x) ,(int)(0.58*h+h1));\r\n        }\r\n        else g.drawString(str.get(1),(int)(x) ,(int)(0.58*h+h1));\r\n\r\n    }\r\n\r\n    private double[] getWidth(String s, Graphics g, Font f)\r\n    {\r\n        double[] arr=new double[2];//w,h\r\n        g.setColor(Color.BLACK);\r\n        Rectangle2D p=g.getFontMetrics(f).getStringBounds(s,g);\r\n        arr[0]= p.getWidth();\r\n        arr[1]=p.getHeight();\r\n        return arr;\r\n    }\r\n    private void drawGraph(Graphics g) {\r\n        directed_weighted_graph gg = _ar.getGraph();\r\n        Iterator<node_data> iter = gg.getV().iterator();\r\n        while(iter.hasNext()) {\r\n            node_data n = iter.next();\r\n            Iterator<edge_data> itr = gg.getE(n.getKey()).iterator();\r\n            while(itr.hasNext()) {\r\n                edge_data e = itr.next();\r\n                g.setColor(Color.black);\r\n                drawEdge(e, g);\r\n            }\r\n        }\r\n        Iterator<node_data> iter1 = gg.getV().iterator();\r\n        while(iter1.hasNext()) {\r\n            node_data n = iter1.next();\r\n            g.setColor(new Color(221,183, 63 ));\r\n            drawNode(n,12,g);\r\n\r\n        }\r\n    }\r\n    private void drawPokemons(Graphics g) {\r\n        List<Pokemon> fs = _ar.getPokemons();\r\n        for (int i=0; i<fs.size();i++) {\r\n            Pokemon p = fs.get(i);\r\n            double x=p.getPos().x(), y=p.getPos().y(), z=p.getPos().z();\r\n            Point3D c = new Point3D(x,y,z);\r\n            int r=14;\r\n            g.setColor(Color.green);\r\n            if(p.getType()<0) {g.setColor(Color.orange);}\r\n            if(c!=null) {\r\n\r\n                geo_location fp = this._w2f.world2frame(c);\r\n                pokemon=new ImageIcon(\"src//gameClient//files//pokemonBall.png\");\r\n                Image pokemon1 = pokemon.getImage();\r\n                Image pokemon2 = pokemon1.getScaledInstance(2*r+4, 2*r,Image.SCALE_DEFAULT);\r\n                pokemon=new ImageIcon(pokemon2);\r\n                pokemon.paintIcon(this, g, (int)fp.x()-r-2,(int)fp.y()-r);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void drawAgants(Graphics g) {\r\n        List<Agent> rs = _ar.getAgents();\r\n        //\tIterator<OOP_Point3D> itr = rs.iterator();\r\n        g.setColor(Color.red);\r\n        int i=0;\r\n        while(rs!=null && i<rs.size()) {\r\n            geo_location c = rs.get(i).getPos();\r\n            int r=8;\r\n            if(c!=null) {\r\n\r\n                geo_location fp = this._w2f.world2frame(c);\r\n\r\n                agent=new ImageIcon(\"src//gameClient//files//pikachu.png\");\r\n                Image agent1 = agent.getImage();\r\n                Image agent2 = agent1.getScaledInstance(10*r, 12*r,Image.SCALE_DEFAULT);\r\n                agent=new ImageIcon(agent2);\r\n                int x=(int)fp.x()-4*r, y=(int)fp.y()-6*r;\r\n                agent.paintIcon(this, g,x ,y);\r\n                Font f=new Font(\"SansSerif\", Font.BOLD, 12);\r\n                g.setFont(f);\r\n                g.setColor(Color.BLACK);\r\n                // new Color(220, 36,36)\r\n                double Value= rs.get(i).getValue();\r\n                g.drawString(\"Value: \"+Value, x-3, y-5);\r\n                //  g.drawString(\"Speed: \"+rs.get(i).getSpeed(), x-, y-20);\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n    private void drawNode(node_data n, int r, Graphics g) {\r\n        geo_location pos = n.getLocation();\r\n        geo_location fp = this._w2f.world2frame(pos);\r\n        g.fillOval((int)fp.x()-r, (int)fp.y()-r, 2*r, 2*r);\r\n        g.setColor(Color.BLACK);\r\n        Font f=new Font(\"SansSerif\", Font.CENTER_BASELINE, 12);\r\n        g.setFont(f);\r\n        g.drawString(\"\"+n.getKey(), (int)fp.x()-5, (int)fp.y()+4);\r\n    }\r\n    private void drawEdge(edge_data e, Graphics g) {\r\n        directed_weighted_graph gg = _ar.getGraph();\r\n        geo_location s = gg.getNode(e.getSrc()).getLocation();\r\n        geo_location d = gg.getNode(e.getDest()).getLocation();\r\n        geo_location s0 = this._w2f.world2frame(s);\r\n        geo_location d0 = this._w2f.world2frame(d);\r\n        Graphics2D g1= (Graphics2D)g;\r\n        g1.setStroke(new BasicStroke(2));\r\n        g1.drawLine((int)s0.x(), (int)s0.y(), (int)d0.x(), (int)d0.y());\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/gameClient/GameFrame.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ src/gameClient/GameFrame.java	(date 1608448604840)
@@ -143,7 +143,7 @@
             if(c!=null) {
 
                 geo_location fp = this._w2f.world2frame(c);
-                pokemon=new ImageIcon("src//gameClient//files//pokemonBall.png");
+                pokemon=new ImageIcon("data//images//pokemonBall.png");
                 Image pokemon1 = pokemon.getImage();
                 Image pokemon2 = pokemon1.getScaledInstance(2*r+4, 2*r,Image.SCALE_DEFAULT);
                 pokemon=new ImageIcon(pokemon2);
@@ -163,8 +163,7 @@
             if(c!=null) {
 
                 geo_location fp = this._w2f.world2frame(c);
-
-                agent=new ImageIcon("src//gameClient//files//pikachu.png");
+                agent=new ImageIcon("data//images//pikachu.png");
                 Image agent1 = agent.getImage();
                 Image agent2 = agent1.getScaledInstance(10*r, 12*r,Image.SCALE_DEFAULT);
                 agent=new ImageIcon(agent2);
@@ -175,7 +174,7 @@
                 g.setColor(Color.BLACK);
                 // new Color(220, 36,36)
                 double Value= rs.get(i).getValue();
-                g.drawString("Value: "+Value, x-3, y-5);
+               g.drawString("Value: "+Value, x-3, y-5);
                 //  g.drawString("Speed: "+rs.get(i).getSpeed(), x-, y-20);
             }
             i++;
Index: out/production/OOP_EX2/kotlin-stdlib-1.3.72.jar/META-INF/MANIFEST.MF
===================================================================
--- out/production/OOP_EX2/kotlin-stdlib-1.3.72.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/kotlin-stdlib-1.3.72.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,7 +0,0 @@
-Manifest-Version: 1.0
-Implementation-Title: kotlin-stdlib
-Kotlin-Runtime-Component: Main
-Kotlin-Version: 1.3
-Implementation-Version: 1.3.72-release-468 (1.3.72)
-Implementation-Vendor: JetBrains
-
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONArray.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONArray.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONArray.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,919 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.reflect.Array;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Map;
-
-/**
- * A JSONArray is an ordered sequence of values. Its external text form is a
- * string wrapped in square brackets with commas separating the values. The
- * internal form is an object having <code>get</code> and <code>opt</code>
- * methods for accessing the values by index, and <code>put</code> methods for
- * adding or replacing values. The values can be any of these types:
- * <code>Boolean</code>, <code>JSONArray</code>, <code>JSONObject</code>,
- * <code>Number</code>, <code>String</code>, or the
- * <code>JSONObject.NULL object</code>.
- * <p>
- * The constructor can convert a JSON text into a Java object. The
- * <code>toString</code> method converts to JSON text.
- * <p>
- * A <code>get</code> method returns a value if one can be found, and throws an
- * exception if one cannot be found. An <code>opt</code> method returns a
- * default value instead of throwing an exception, and so is useful for
- * obtaining optional values.
- * <p>
- * The generic <code>get()</code> and <code>opt()</code> methods return an
- * object which you can cast or query for type. There are also typed
- * <code>get</code> and <code>opt</code> methods that do type checking and type
- * coercion for you.
- * <p>
- * The texts produced by the <code>toString</code> methods strictly conform to
- * JSON syntax rules. The constructors are more forgiving in the texts they will
- * accept:
- * <ul>
- * <li>An extra <code>,</code>&nbsp;<small>(comma)</small> may appear just
- *     before the closing bracket.</li>
- * <li>The <code>null</code> value will be inserted when there
- *     is <code>,</code>&nbsp;<small>(comma)</small> elision.</li>
- * <li>Strings may be quoted with <code>'</code>&nbsp;<small>(single
- *     quote)</small>.</li>
- * <li>Strings do not need to be quoted at all if they do not begin with a quote
- *     or single quote, and if they do not contain leading or trailing spaces,
- *     and if they do not contain any of these characters:
- *     <code>{ } [ ] / \ : , = ; #</code> and if they do not look like numbers
- *     and if they are not the reserved words <code>true</code>,
- *     <code>false</code>, or <code>null</code>.</li>
- * <li>Values can be separated by <code>;</code> <small>(semicolon)</small> as
- *     well as by <code>,</code> <small>(comma)</small>.</li>
- * <li>Numbers may have the 
- *     <code>0x-</code> <small>(hex)</small> prefix.</li>
- * </ul>
-
- * @author JSON.org
- * @version 2011-05-04
- */
-public class JSONArray {
-
-
-    /**
-     * The arrayList where the JSONArray's properties are kept.
-     */
-    private ArrayList myArrayList;
-
-
-    /**
-     * Construct an empty JSONArray.
-     */
-    public JSONArray() {
-        this.myArrayList = new ArrayList();
-    }
-
-    /**
-     * Construct a JSONArray from a JSONTokener.
-     * @param x A JSONTokener
-     * @throws JSONException If there is a syntax error.
-     */
-    public JSONArray(JSONTokener x) throws JSONException {
-        this();
-        if (x.nextClean() != '[') {
-            throw x.syntaxError("A JSONArray text must start with '['");
-        }
-        if (x.nextClean() != ']') {
-	        x.back();
-	        for (;;) {
-	            if (x.nextClean() == ',') {
-	                x.back();
-	                this.myArrayList.add(JSONObject.NULL);
-	            } else {
-	                x.back();
-	                this.myArrayList.add(x.nextValue());
-	            }
-	            switch (x.nextClean()) {
-	            case ';':
-	            case ',':
-	                if (x.nextClean() == ']') {
-	                    return;
-	                }
-	                x.back();
-	                break;
-	            case ']':
-	            	return;
-	            default:
-	                throw x.syntaxError("Expected a ',' or ']'");
-	            }
-	        }
-        }
-    }
-
-
-    /**
-     * Construct a JSONArray from a source JSON text.
-     * @param source     A string that begins with
-     * <code>[</code>&nbsp;<small>(left bracket)</small>
-     *  and ends with <code>]</code>&nbsp;<small>(right bracket)</small>.
-     *  @throws JSONException If there is a syntax error.
-     */
-    public JSONArray(String source) throws JSONException {
-        this(new JSONTokener(source));
-    }
-
-
-    /**
-     * Construct a JSONArray from a Collection.
-     * @param collection     A Collection.
-     */
-    public JSONArray(Collection collection) {
-		this.myArrayList = new ArrayList();
-		if (collection != null) {
-			Iterator iter = collection.iterator();
-			while (iter.hasNext()) {
-                this.myArrayList.add(JSONObject.wrap(iter.next()));  
-			}
-		}
-    }
-
-    
-    /**
-     * Construct a JSONArray from an array
-     * @throws JSONException If not an array.
-     */
-    public JSONArray(Object array) throws JSONException {
-        this();
-        if (array.getClass().isArray()) {
-            int length = Array.getLength(array);
-            for (int i = 0; i < length; i += 1) {
-                this.put(JSONObject.wrap(Array.get(array, i)));
-            }
-        } else {
-            throw new JSONException(
-"JSONArray initial value should be a string or collection or array.");
-        }
-    }
-    
-    
-    /**
-     * Get the object value associated with an index.
-     * @param index
-     *  The index must be between 0 and length() - 1.
-     * @return An object value.
-     * @throws JSONException If there is no value for the index.
-     */
-    public Object get(int index) throws JSONException {
-        Object object = opt(index);
-        if (object == null) {
-            throw new JSONException("JSONArray[" + index + "] not found.");
-        }
-        return object;
-    }
-
-
-    /**
-     * Get the boolean value associated with an index.
-     * The string values "true" and "false" are converted to boolean.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The truth.
-     * @throws JSONException If there is no value for the index or if the
-     *  value is not convertible to boolean.
-     */
-    public boolean getBoolean(int index) throws JSONException {
-        Object object = get(index);
-        if (object.equals(Boolean.FALSE) ||
-                (object instanceof String &&
-                ((String)object).equalsIgnoreCase("false"))) {
-            return false;
-        } else if (object.equals(Boolean.TRUE) ||
-                (object instanceof String &&
-                ((String)object).equalsIgnoreCase("true"))) {
-            return true;
-        }
-        throw new JSONException("JSONArray[" + index + "] is not a boolean.");
-    }
-
-
-    /**
-     * Get the double value associated with an index.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The value.
-     * @throws   JSONException If the key is not found or if the value cannot
-     *  be converted to a number.
-     */
-    public double getDouble(int index) throws JSONException {
-        Object object = get(index);
-        try {
-            return object instanceof Number ?
-                ((Number)object).doubleValue() :
-                Double.parseDouble((String)object);
-        } catch (Exception e) {
-            throw new JSONException("JSONArray[" + index +
-                "] is not a number.");
-        }
-    }
-
-
-    /**
-     * Get the int value associated with an index.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The value.
-     * @throws   JSONException If the key is not found or if the value is not a number.
-     */
-    public int getInt(int index) throws JSONException {
-        Object object = get(index);
-        try {
-            return object instanceof Number ?
-                ((Number)object).intValue() :
-                Integer.parseInt((String)object);
-        } catch (Exception e) {
-            throw new JSONException("JSONArray[" + index +
-                "] is not a number.");
-        }
-    }
-
-
-    /**
-     * Get the JSONArray associated with an index.
-     * @param index The index must be between 0 and length() - 1.
-     * @return      A JSONArray value.
-     * @throws JSONException If there is no value for the index. or if the
-     * value is not a JSONArray
-     */
-    public JSONArray getJSONArray(int index) throws JSONException {
-        Object object = get(index);
-        if (object instanceof JSONArray) {
-            return (JSONArray)object;
-        }
-        throw new JSONException("JSONArray[" + index +
-                "] is not a JSONArray.");
-    }
-
-
-    /**
-     * Get the JSONObject associated with an index.
-     * @param index subscript
-     * @return      A JSONObject value.
-     * @throws JSONException If there is no value for the index or if the
-     * value is not a JSONObject
-     */
-    public JSONObject getJSONObject(int index) throws JSONException {
-        Object object = get(index);
-        if (object instanceof JSONObject) {
-            return (JSONObject)object;
-        }
-        throw new JSONException("JSONArray[" + index +
-            "] is not a JSONObject.");
-    }
-
-
-    /**
-     * Get the long value associated with an index.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The value.
-     * @throws   JSONException If the key is not found or if the value cannot
-     *  be converted to a number.
-     */
-    public long getLong(int index) throws JSONException {
-        Object object = get(index);
-        try {
-            return object instanceof Number ?
-                ((Number)object).longValue() :
-                Long.parseLong((String)object);
-        } catch (Exception e) {
-            throw new JSONException("JSONArray[" + index +
-                "] is not a number.");
-        }
-    }
-
-
-    /**
-     * Get the string associated with an index.
-     * @param index The index must be between 0 and length() - 1.
-     * @return      A string value.
-     * @throws JSONException If there is no string value for the index.
-     */
-    public String getString(int index) throws JSONException {
-        Object object = get(index);
-        if (object instanceof String) {
-            return (String)object;
-        }
-        throw new JSONException("JSONArray[" + index + "] not a string.");
-    }
-
-
-    /**
-     * Determine if the value is null.
-     * @param index The index must be between 0 and length() - 1.
-     * @return true if the value at the index is null, or if there is no value.
-     */
-    public boolean isNull(int index) {
-        return JSONObject.NULL.equals(opt(index));
-    }
-
-
-    /**
-     * Make a string from the contents of this JSONArray. The
-     * <code>separator</code> string is inserted between each element.
-     * Warning: This method assumes that the data structure is acyclical.
-     * @param separator A string that will be inserted between the elements.
-     * @return a string.
-     * @throws JSONException If the array contains an invalid number.
-     */
-    public String join(String separator) throws JSONException {
-        int len = length();
-        StringBuffer sb = new StringBuffer();
-
-        for (int i = 0; i < len; i += 1) {
-            if (i > 0) {
-                sb.append(separator);
-            }
-            sb.append(JSONObject.valueToString(this.myArrayList.get(i)));
-        }
-        return sb.toString();
-    }
-
-
-    /**
-     * Get the number of elements in the JSONArray, included nulls.
-     *
-     * @return The length (or size).
-     */
-    public int length() {
-        return this.myArrayList.size();
-    }
-
-
-    /**
-     * Get the optional object value associated with an index.
-     * @param index The index must be between 0 and length() - 1.
-     * @return      An object value, or null if there is no
-     *              object at that index.
-     */
-    public Object opt(int index) {
-        return (index < 0 || index >= length()) ?
-            null : this.myArrayList.get(index);
-    }
-
-
-    /**
-     * Get the optional boolean value associated with an index.
-     * It returns false if there is no value at that index,
-     * or if the value is not Boolean.TRUE or the String "true".
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The truth.
-     */
-    public boolean optBoolean(int index)  {
-        return optBoolean(index, false);
-    }
-
-
-    /**
-     * Get the optional boolean value associated with an index.
-     * It returns the defaultValue if there is no value at that index or if
-     * it is not a Boolean or the String "true" or "false" (case insensitive).
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @param defaultValue     A boolean default.
-     * @return      The truth.
-     */
-    public boolean optBoolean(int index, boolean defaultValue)  {
-        try {
-            return getBoolean(index);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get the optional double value associated with an index.
-     * NaN is returned if there is no value for the index,
-     * or if the value is not a number and cannot be converted to a number.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The value.
-     */
-    public double optDouble(int index) {
-        return optDouble(index, Double.NaN);
-    }
-
-
-    /**
-     * Get the optional double value associated with an index.
-     * The defaultValue is returned if there is no value for the index,
-     * or if the value is not a number and cannot be converted to a number.
-     *
-     * @param index subscript
-     * @param defaultValue     The default value.
-     * @return      The value.
-     */
-    public double optDouble(int index, double defaultValue) {
-        try {
-            return getDouble(index);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get the optional int value associated with an index.
-     * Zero is returned if there is no value for the index,
-     * or if the value is not a number and cannot be converted to a number.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The value.
-     */
-    public int optInt(int index) {
-        return optInt(index, 0);
-    }
-
-
-    /**
-     * Get the optional int value associated with an index.
-     * The defaultValue is returned if there is no value for the index,
-     * or if the value is not a number and cannot be converted to a number.
-     * @param index The index must be between 0 and length() - 1.
-     * @param defaultValue     The default value.
-     * @return      The value.
-     */
-    public int optInt(int index, int defaultValue) {
-        try {
-            return getInt(index);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get the optional JSONArray associated with an index.
-     * @param index subscript
-     * @return      A JSONArray value, or null if the index has no value,
-     * or if the value is not a JSONArray.
-     */
-    public JSONArray optJSONArray(int index) {
-        Object o = opt(index);
-        return o instanceof JSONArray ? (JSONArray)o : null;
-    }
-
-
-    /**
-     * Get the optional JSONObject associated with an index.
-     * Null is returned if the key is not found, or null if the index has
-     * no value, or if the value is not a JSONObject.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      A JSONObject value.
-     */
-    public JSONObject optJSONObject(int index) {
-        Object o = opt(index);
-        return o instanceof JSONObject ? (JSONObject)o : null;
-    }
-
-
-    /**
-     * Get the optional long value associated with an index.
-     * Zero is returned if there is no value for the index,
-     * or if the value is not a number and cannot be converted to a number.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      The value.
-     */
-    public long optLong(int index) {
-        return optLong(index, 0);
-    }
-
-
-    /**
-     * Get the optional long value associated with an index.
-     * The defaultValue is returned if there is no value for the index,
-     * or if the value is not a number and cannot be converted to a number.
-     * @param index The index must be between 0 and length() - 1.
-     * @param defaultValue     The default value.
-     * @return      The value.
-     */
-    public long optLong(int index, long defaultValue) {
-        try {
-            return getLong(index);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get the optional string value associated with an index. It returns an
-     * empty string if there is no value at that index. If the value
-     * is not a string and is not null, then it is coverted to a string.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @return      A String value.
-     */
-    public String optString(int index) {
-        return optString(index, "");
-    }
-
-
-    /**
-     * Get the optional string associated with an index.
-     * The defaultValue is returned if the key is not found.
-     *
-     * @param index The index must be between 0 and length() - 1.
-     * @param defaultValue     The default value.
-     * @return      A String value.
-     */
-    public String optString(int index, String defaultValue) {
-        Object object = opt(index);
-        return object != null ? object.toString() : defaultValue;
-    }
-
-
-    /**
-     * Append a boolean value. This increases the array's length by one.
-     *
-     * @param value A boolean value.
-     * @return this.
-     */
-    public JSONArray put(boolean value) {
-        put(value ? Boolean.TRUE : Boolean.FALSE);
-        return this;
-    }
-
-
-    /**
-     * Put a value in the JSONArray, where the value will be a
-     * JSONArray which is produced from a Collection.
-     * @param value A Collection value.
-     * @return      this.
-     */
-    public JSONArray put(Collection value) {
-        put(new JSONArray(value));
-        return this;
-    }
-
-
-    /**
-     * Append a double value. This increases the array's length by one.
-     *
-     * @param value A double value.
-     * @throws JSONException if the value is not finite.
-     * @return this.
-     */
-    public JSONArray put(double value) throws JSONException {
-        Double d = new Double(value);
-        JSONObject.testValidity(d);
-        put(d);
-        return this;
-    }
-
-
-    /**
-     * Append an int value. This increases the array's length by one.
-     *
-     * @param value An int value.
-     * @return this.
-     */
-    public JSONArray put(int value) {
-        put(new Integer(value));
-        return this;
-    }
-
-
-    /**
-     * Append an long value. This increases the array's length by one.
-     *
-     * @param value A long value.
-     * @return this.
-     */
-    public JSONArray put(long value) {
-        put(new Long(value));
-        return this;
-    }
-
-
-    /**
-     * Put a value in the JSONArray, where the value will be a
-     * JSONObject which is produced from a Map.
-     * @param value A Map value.
-     * @return      this.
-     */
-    public JSONArray put(Map value) {
-        put(new JSONObject(value));
-        return this;
-    }
-
-
-    /**
-     * Append an object value. This increases the array's length by one.
-     * @param value An object value.  The value should be a
-     *  Boolean, Double, Integer, JSONArray, JSONObject, Long, or String, or the
-     *  JSONObject.NULL object.
-     * @return this.
-     */
-    public JSONArray put(Object value) {
-        this.myArrayList.add(value);
-        return this;
-    }
-
-
-    /**
-     * Put or replace a boolean value in the JSONArray. If the index is greater
-     * than the length of the JSONArray, then null elements will be added as
-     * necessary to pad it out.
-     * @param index The subscript.
-     * @param value A boolean value.
-     * @return this.
-     * @throws JSONException If the index is negative.
-     */
-    public JSONArray put(int index, boolean value) throws JSONException {
-        put(index, value ? Boolean.TRUE : Boolean.FALSE);
-        return this;
-    }
-
-
-    /**
-     * Put a value in the JSONArray, where the value will be a
-     * JSONArray which is produced from a Collection.
-     * @param index The subscript.
-     * @param value A Collection value.
-     * @return      this.
-     * @throws JSONException If the index is negative or if the value is
-     * not finite.
-     */
-    public JSONArray put(int index, Collection value) throws JSONException {
-        put(index, new JSONArray(value));
-        return this;
-    }
-
-
-    /**
-     * Put or replace a double value. If the index is greater than the length of
-     *  the JSONArray, then null elements will be added as necessary to pad
-     *  it out.
-     * @param index The subscript.
-     * @param value A double value.
-     * @return this.
-     * @throws JSONException If the index is negative or if the value is
-     * not finite.
-     */
-    public JSONArray put(int index, double value) throws JSONException {
-        put(index, new Double(value));
-        return this;
-    }
-
-
-    /**
-     * Put or replace an int value. If the index is greater than the length of
-     *  the JSONArray, then null elements will be added as necessary to pad
-     *  it out.
-     * @param index The subscript.
-     * @param value An int value.
-     * @return this.
-     * @throws JSONException If the index is negative.
-     */
-    public JSONArray put(int index, int value) throws JSONException {
-        put(index, new Integer(value));
-        return this;
-    }
-
-
-    /**
-     * Put or replace a long value. If the index is greater than the length of
-     *  the JSONArray, then null elements will be added as necessary to pad
-     *  it out.
-     * @param index The subscript.
-     * @param value A long value.
-     * @return this.
-     * @throws JSONException If the index is negative.
-     */
-    public JSONArray put(int index, long value) throws JSONException {
-        put(index, new Long(value));
-        return this;
-    }
-
-
-    /**
-     * Put a value in the JSONArray, where the value will be a
-     * JSONObject that is produced from a Map.
-     * @param index The subscript.
-     * @param value The Map value.
-     * @return      this.
-     * @throws JSONException If the index is negative or if the the value is
-     *  an invalid number.
-     */
-    public JSONArray put(int index, Map value) throws JSONException {
-        put(index, new JSONObject(value));
-        return this;
-    }
-
-
-    /**
-     * Put or replace an object value in the JSONArray. If the index is greater
-     *  than the length of the JSONArray, then null elements will be added as
-     *  necessary to pad it out.
-     * @param index The subscript.
-     * @param value The value to put into the array. The value should be a
-     *  Boolean, Double, Integer, JSONArray, JSONObject, Long, or String, or the
-     *  JSONObject.NULL object.
-     * @return this.
-     * @throws JSONException If the index is negative or if the the value is
-     *  an invalid number.
-     */
-    public JSONArray put(int index, Object value) throws JSONException {
-        JSONObject.testValidity(value);
-        if (index < 0) {
-            throw new JSONException("JSONArray[" + index + "] not found.");
-        }
-        if (index < length()) {
-            this.myArrayList.set(index, value);
-        } else {
-            while (index != length()) {
-                put(JSONObject.NULL);
-            }
-            put(value);
-        }
-        return this;
-    }
-    
-    
-    /**
-     * Remove an index and close the hole.
-     * @param index The index of the element to be removed.
-     * @return The value that was associated with the index,
-     * or null if there was no value.
-     */
-    public Object remove(int index) {
-    	Object o = opt(index);
-        this.myArrayList.remove(index);
-        return o;
-    }
-
-
-    /**
-     * Produce a JSONObject by combining a JSONArray of names with the values
-     * of this JSONArray.
-     * @param names A JSONArray containing a list of key strings. These will be
-     * paired with the values.
-     * @return A JSONObject, or null if there are no names or if this JSONArray
-     * has no values.
-     * @throws JSONException If any of the names are null.
-     */
-    public JSONObject toJSONObject(JSONArray names) throws JSONException {
-        if (names == null || names.length() == 0 || length() == 0) {
-            return null;
-        }
-        JSONObject jo = new JSONObject();
-        for (int i = 0; i < names.length(); i += 1) {
-            jo.put(names.getString(i), this.opt(i));
-        }
-        return jo;
-    }
-
-
-    /**
-     * Make a JSON text of this JSONArray. For compactness, no
-     * unnecessary whitespace is added. If it is not possible to produce a
-     * syntactically correct JSON text then null will be returned instead. This
-     * could occur if the array contains an invalid number.
-     * <p>
-     * Warning: This method assumes that the data structure is acyclical.
-     *
-     * @return a printable, displayable, transmittable
-     *  representation of the array.
-     */
-    public String toString() {
-        try {
-            return '[' + join(",") + ']';
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-
-    /**
-     * Make a prettyprinted JSON text of this JSONArray.
-     * Warning: This method assumes that the data structure is acyclical.
-     * @param indentFactor The number of spaces to add to each level of
-     *  indentation.
-     * @return a printable, displayable, transmittable
-     *  representation of the object, beginning
-     *  with <code>[</code>&nbsp;<small>(left bracket)</small> and ending
-     *  with <code>]</code>&nbsp;<small>(right bracket)</small>.
-     * @throws JSONException
-     */
-    public String toString(int indentFactor) throws JSONException {
-        return toString(indentFactor, 0);
-    }
-
-
-    /**
-     * Make a prettyprinted JSON text of this JSONArray.
-     * Warning: This method assumes that the data structure is acyclical.
-     * @param indentFactor The number of spaces to add to each level of
-     *  indentation.
-     * @param indent The indention of the top level.
-     * @return a printable, displayable, transmittable
-     *  representation of the array.
-     * @throws JSONException
-     */
-    String toString(int indentFactor, int indent) throws JSONException {
-        int len = length();
-        if (len == 0) {
-            return "[]";
-        }
-        int i;
-        StringBuffer sb = new StringBuffer("[");
-        if (len == 1) {
-            sb.append(JSONObject.valueToString(this.myArrayList.get(0),
-                    indentFactor, indent));
-        } else {
-            int newindent = indent + indentFactor;
-            sb.append('\n');
-            for (i = 0; i < len; i += 1) {
-                if (i > 0) {
-                    sb.append(",\n");
-                }
-                for (int j = 0; j < newindent; j += 1) {
-                    sb.append(' ');
-                }
-                sb.append(JSONObject.valueToString(this.myArrayList.get(i),
-                        indentFactor, newindent));
-            }
-            sb.append('\n');
-            for (i = 0; i < indent; i += 1) {
-                sb.append(' ');
-            }
-        }
-        sb.append(']');
-        return sb.toString();
-    }
-
-
-    /**
-     * Write the contents of the JSONArray as JSON text to a writer.
-     * For compactness, no whitespace is added.
-     * <p>
-     * Warning: This method assumes that the data structure is acyclical.
-     *
-     * @return The writer.
-     * @throws JSONException
-     */
-    public Writer write(Writer writer) throws JSONException {
-        try {
-            boolean b = false;
-            int     len = length();
-
-            writer.write('[');
-
-            for (int i = 0; i < len; i += 1) {
-                if (b) {
-                    writer.write(',');
-                }
-                Object v = this.myArrayList.get(i);
-                if (v instanceof JSONObject) {
-                    ((JSONObject)v).write(writer);
-                } else if (v instanceof JSONArray) {
-                    ((JSONArray)v).write(writer);
-                } else {
-                    writer.write(JSONObject.valueToString(v));
-                }
-                b = true;
-            }
-            writer.write(']');
-            return writer;
-        } catch (IOException e) {
-           throw new JSONException(e);
-        }
-    }
-}
\ No newline at end of file
Index: out/production/OOP_EX2/java-json.jar/org/json/XML.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/XML.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/XML.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,508 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-import java.util.Iterator;
-
-
-/**
- * This provides static methods to convert an XML text into a JSONObject,
- * and to covert a JSONObject into an XML text.
- * @author JSON.org
- * @version 2011-02-11
- */
-public class XML {
-
-    /** The Character '&'. */
-    public static final Character AMP   = new Character('&');
-
-    /** The Character '''. */
-    public static final Character APOS  = new Character('\'');
-
-    /** The Character '!'. */
-    public static final Character BANG  = new Character('!');
-
-    /** The Character '='. */
-    public static final Character EQ    = new Character('=');
-
-    /** The Character '>'. */
-    public static final Character GT    = new Character('>');
-
-    /** The Character '<'. */
-    public static final Character LT    = new Character('<');
-
-    /** The Character '?'. */
-    public static final Character QUEST = new Character('?');
-
-    /** The Character '"'. */
-    public static final Character QUOT  = new Character('"');
-
-    /** The Character '/'. */
-    public static final Character SLASH = new Character('/');
-
-    /**
-     * Replace special characters with XML escapes:
-     * <pre>
-     * &amp; <small>(ampersand)</small> is replaced by &amp;amp;
-     * &lt; <small>(less than)</small> is replaced by &amp;lt;
-     * &gt; <small>(greater than)</small> is replaced by &amp;gt;
-     * &quot; <small>(double quote)</small> is replaced by &amp;quot;
-     * </pre>
-     * @param string The string to be escaped.
-     * @return The escaped string.
-     */
-    public static String escape(String string) {
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0, length = string.length(); i < length; i++) {
-            char c = string.charAt(i);
-            switch (c) {
-            case '&':
-                sb.append("&amp;");
-                break;
-            case '<':
-                sb.append("&lt;");
-                break;
-            case '>':
-                sb.append("&gt;");
-                break;
-            case '"':
-                sb.append("&quot;");
-                break;
-            case '\'':
-                sb.append("&apos;");
-                break;
-            default:
-                sb.append(c);
-            }
-        }
-        return sb.toString();
-    }
-    
-    /**
-     * Throw an exception if the string contains whitespace. 
-     * Whitespace is not allowed in tagNames and attributes.
-     * @param string
-     * @throws JSONException
-     */
-    public static void noSpace(String string) throws JSONException {
-    	int i, length = string.length();
-    	if (length == 0) {
-    		throw new JSONException("Empty string.");
-    	}
-    	for (i = 0; i < length; i += 1) {
-		    if (Character.isWhitespace(string.charAt(i))) {
-		    	throw new JSONException("'" + string + 
-		    			"' contains a space character.");
-		    }
-		}
-    }
-
-    /**
-     * Scan the content following the named tag, attaching it to the context.
-     * @param x       The XMLTokener containing the source string.
-     * @param context The JSONObject that will include the new material.
-     * @param name    The tag name.
-     * @return true if the close tag is processed.
-     * @throws JSONException
-     */
-    private static boolean parse(XMLTokener x, JSONObject context,
-                                 String name) throws JSONException {
-        char       c;
-        int        i;
-        JSONObject jsonobject = null;
-        String     string;
-        String     tagName;
-        Object     token;
-
-// Test for and skip past these forms:
-//      <!-- ... -->
-//      <!   ...   >
-//      <![  ... ]]>
-//      <?   ...  ?>
-// Report errors for these forms:
-//      <>
-//      <=
-//      <<
-
-        token = x.nextToken();
-
-// <!
-
-        if (token == BANG) {
-            c = x.next();
-            if (c == '-') {
-                if (x.next() == '-') {
-                    x.skipPast("-->");
-                    return false;
-                }
-                x.back();
-            } else if (c == '[') {
-                token = x.nextToken();
-                if (token.equals("CDATA")) {
-                    if (x.next() == '[') {
-                        string = x.nextCDATA();
-                        if (string.length() > 0) {
-                            context.accumulate("content", string);
-                        }
-                        return false;
-                    }
-                }
-                throw x.syntaxError("Expected 'CDATA['");
-            }
-            i = 1;
-            do {
-                token = x.nextMeta();
-                if (token == null) {
-                    throw x.syntaxError("Missing '>' after '<!'.");
-                } else if (token == LT) {
-                    i += 1;
-                } else if (token == GT) {
-                    i -= 1;
-                }
-            } while (i > 0);
-            return false;
-        } else if (token == QUEST) {
-
-// <?
-
-            x.skipPast("?>");
-            return false;
-        } else if (token == SLASH) {
-
-// Close tag </
-
-        	token = x.nextToken();
-            if (name == null) {
-                throw x.syntaxError("Mismatched close tag " + token);
-            }            
-            if (!token.equals(name)) {
-                throw x.syntaxError("Mismatched " + name + " and " + token);
-            }
-            if (x.nextToken() != GT) {
-                throw x.syntaxError("Misshaped close tag");
-            }
-            return true;
-
-        } else if (token instanceof Character) {
-            throw x.syntaxError("Misshaped tag");
-
-// Open tag <
-
-        } else {
-            tagName = (String)token;
-            token = null;
-            jsonobject = new JSONObject();
-            for (;;) {
-                if (token == null) {
-                    token = x.nextToken();
-                }
-
-// attribute = value
-
-                if (token instanceof String) {
-                    string = (String)token;
-                    token = x.nextToken();
-                    if (token == EQ) {
-                        token = x.nextToken();
-                        if (!(token instanceof String)) {
-                            throw x.syntaxError("Missing value");
-                        }
-                        jsonobject.accumulate(string, 
-                        		XML.stringToValue((String)token));
-                        token = null;
-                    } else {
-                        jsonobject.accumulate(string, "");
-                    }
-
-// Empty tag <.../>
-
-                } else if (token == SLASH) {
-                    if (x.nextToken() != GT) {
-                        throw x.syntaxError("Misshaped tag");
-                    }
-                    if (jsonobject.length() > 0) {
-                        context.accumulate(tagName, jsonobject);
-                    } else {
-                    	context.accumulate(tagName, "");
-                    }
-                    return false;
-
-// Content, between <...> and </...>
-
-                } else if (token == GT) {
-                    for (;;) {
-                        token = x.nextContent();
-                        if (token == null) {
-                            if (tagName != null) {
-                                throw x.syntaxError("Unclosed tag " + tagName);
-                            }
-                            return false;
-                        } else if (token instanceof String) {
-                            string = (String)token;
-                            if (string.length() > 0) {
-                                jsonobject.accumulate("content", 
-                                		XML.stringToValue(string));
-                            }
-
-// Nested element
-
-                        } else if (token == LT) {
-                            if (parse(x, jsonobject, tagName)) {
-                                if (jsonobject.length() == 0) {
-                                    context.accumulate(tagName, "");
-                                } else if (jsonobject.length() == 1 &&
-                                       jsonobject.opt("content") != null) {
-                                    context.accumulate(tagName, 
-                                    		jsonobject.opt("content"));
-                                } else {
-                                    context.accumulate(tagName, jsonobject);
-                                }
-                                return false;
-                            }
-                        }
-                    }
-                } else {
-                    throw x.syntaxError("Misshaped tag");
-                }
-            }
-        }
-    }
-
-
-    /**
-     * Try to convert a string into a number, boolean, or null. If the string
-     * can't be converted, return the string. This is much less ambitious than
-     * JSONObject.stringToValue, especially because it does not attempt to
-     * convert plus forms, octal forms, hex forms, or E forms lacking decimal 
-     * points.
-     * @param string A String.
-     * @return A simple JSON value.
-     */
-    public static Object stringToValue(String string) {
-        if (string.equals("")) {
-            return string;
-        }
-        if (string.equalsIgnoreCase("true")) {
-            return Boolean.TRUE;
-        }
-        if (string.equalsIgnoreCase("false")) {
-            return Boolean.FALSE;
-        }
-        if (string.equalsIgnoreCase("null")) {
-            return JSONObject.NULL;
-        }
-        if (string.equals("0")) {
-            return new Integer(0);
-        }
-
-// If it might be a number, try converting it. If that doesn't work, 
-// return the string.
-
-        try {
-	        char initial = string.charAt(0);
-	        boolean negative = false;
-	        if (initial == '-') {
-	        	initial = string.charAt(1);
-	        	negative = true;
-	        }
-	        if (initial == '0' && string.charAt(negative ? 2 : 1) == '0') {
-	        	return string;
-	        }
-	        if ((initial >= '0' && initial <= '9')) {
-                if (string.indexOf('.') >= 0) {
-                    return Double.valueOf(string);
-                } else if (string.indexOf('e') < 0 && string.indexOf('E') < 0) {
-                    Long myLong = new Long(string);
-                    if (myLong.longValue() == myLong.intValue()) {
-                        return new Integer(myLong.intValue());
-                    } else {
-                        return myLong;
-                    }
-                }
-	        }
-        }  catch (Exception ignore) {
-        }
-        return string;
-    }
-
-    
-    /**
-     * Convert a well-formed (but not necessarily valid) XML string into a
-     * JSONObject. Some information may be lost in this transformation
-     * because JSON is a data format and XML is a document format. XML uses
-     * elements, attributes, and content text, while JSON uses unordered
-     * collections of name/value pairs and arrays of values. JSON does not
-     * does not like to distinguish between elements and attributes.
-     * Sequences of similar elements are represented as JSONArrays. Content
-     * text may be placed in a "content" member. Comments, prologs, DTDs, and
-     * <code>&lt;[ [ ]]></code> are ignored.
-     * @param string The source string.
-     * @return A JSONObject containing the structured data from the XML string.
-     * @throws JSONException
-     */
-    public static JSONObject toJSONObject(String string) throws JSONException {
-        JSONObject jo = new JSONObject();
-        XMLTokener x = new XMLTokener(string);
-        while (x.more() && x.skipPast("<")) {
-            parse(x, jo, null);
-        }
-        return jo;
-    }
-
-
-    /**
-     * Convert a JSONObject into a well-formed, element-normal XML string.
-     * @param object A JSONObject.
-     * @return  A string.
-     * @throws  JSONException
-     */
-    public static String toString(Object object) throws JSONException {
-        return toString(object, null);
-    }
-
-
-    /**
-     * Convert a JSONObject into a well-formed, element-normal XML string.
-     * @param object A JSONObject.
-     * @param tagName The optional name of the enclosing tag.
-     * @return A string.
-     * @throws JSONException
-     */
-    public static String toString(Object object, String tagName)
-            throws JSONException {
-        StringBuffer sb = new StringBuffer();
-        int          i;
-        JSONArray    ja;
-        JSONObject   jo;
-        String       key;
-        Iterator     keys;
-        int          length;
-        String       string;
-        Object       value;
-        if (object instanceof JSONObject) {
-
-// Emit <tagName>
-
-            if (tagName != null) {
-                sb.append('<');
-                sb.append(tagName);
-                sb.append('>');
-            }
-
-// Loop thru the keys.
-
-            jo = (JSONObject)object;
-            keys = jo.keys();
-            while (keys.hasNext()) {
-                key = keys.next().toString();
-                value = jo.opt(key);
-                if (value == null) {
-                	value = "";
-                }
-                if (value instanceof String) {
-                    string = (String)value;
-                } else {
-                    string = null;
-                }
-
-// Emit content in body
-
-                if (key.equals("content")) {
-                    if (value instanceof JSONArray) {
-                        ja = (JSONArray)value;
-                        length = ja.length();
-                        for (i = 0; i < length; i += 1) {
-                            if (i > 0) {
-                                sb.append('\n');
-                            }
-                            sb.append(escape(ja.get(i).toString()));
-                        }
-                    } else {
-                        sb.append(escape(value.toString()));
-                    }
-
-// Emit an array of similar keys
-
-                } else if (value instanceof JSONArray) {
-                    ja = (JSONArray)value;
-                    length = ja.length();
-                    for (i = 0; i < length; i += 1) {
-                        value = ja.get(i);
-                        if (value instanceof JSONArray) {
-                            sb.append('<');
-                            sb.append(key);
-                            sb.append('>');
-                            sb.append(toString(value));
-                            sb.append("</");
-                            sb.append(key);
-                            sb.append('>');
-                        } else {
-                            sb.append(toString(value, key));
-                        }
-                    }
-                } else if (value.equals("")) {
-                    sb.append('<');
-                    sb.append(key);
-                    sb.append("/>");
-
-// Emit a new tag <k>
-
-                } else {
-                    sb.append(toString(value, key));
-                }
-            }
-            if (tagName != null) {
-
-// Emit the </tagname> close tag
-
-                sb.append("</");
-                sb.append(tagName);
-                sb.append('>');
-            }
-            return sb.toString();
-
-// XML does not have good support for arrays. If an array appears in a place
-// where XML is lacking, synthesize an <array> element.
-
-        } else {
-            if (object.getClass().isArray()) {
-                object = new JSONArray(object);
-            }
-            if (object instanceof JSONArray) {
-                ja = (JSONArray)object;
-                length = ja.length();
-                for (i = 0; i < length; i += 1) {
-                    sb.append(toString(ja.opt(i), tagName == null ? "array" : tagName));
-                }
-                return sb.toString();
-            } else {
-                string = (object == null) ? "null" : escape(object.toString());
-                return (tagName == null) ? "\"" + string + "\"" :
-                    (string.length() == 0) ? "<" + tagName + "/>" :
-                    "<" + tagName + ">" + string + "</" + tagName + ">";
-            }
-        }
-    }
-}
\ No newline at end of file
Index: out/production/OOP_EX2/okio-2.7.0.jar/META-INF/MANIFEST.MF
===================================================================
--- out/production/OOP_EX2/okio-2.7.0.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/okio-2.7.0.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,2 +0,0 @@
-Manifest-Version: 1.0
-
Index: src/gameClient/files/FinalGui.java
===================================================================
--- src/gameClient/files/FinalGui.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ src/gameClient/files/FinalGui.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,97 +0,0 @@
-package gameClient.files;
-
-import javax.sound.sampled.*;
-import javax.swing.*;
-import java.awt.*;
-import java.io.File;
-import java.io.IOException;
-
-public class FinalGui extends JFrame {
-    public static void main(String[] args) {
-        FinalGui e=new FinalGui();
-        e.setVisible(true);
-    }
-    private int h=360;
-    private int w=728;
-    private ImageIcon pokemon;
-    private JLabel label1;
-    private JButton unMute;
-    private JPanel panel;
-    private Graphics gra;
-    private Image im;
-    private static JTextField UseNameText;
-    private static JLabel User_Name_Label;
-
-    FinalGui(){
-        initGui();
-    }
-
-    private void initGui()
-    {
-        Icon UM = new ImageIcon("C://Users// //IdeaProjects//OOP_EX2//src//gameClient//files//unmute.jpg");
-        unMute = new JButton(UM);
-        unMute.setVisible(true);
-        unMute.setBounds(0, 0, 400, 350);
-        this.setSize(w,h);
-        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
-        this.setResizable(true);
-        panel=new JPanel();
-        //label1=new JLabel();
-        panel.setLayout(null);
-        this.add(panel);
-        panel.add(unMute);
-//        try {
-//            playMusic();
-//        } catch (IOException e) {
-//            e.printStackTrace();
-//        } catch (UnsupportedAudioFileException e) {
-//            e.printStackTrace();
-//        } catch (LineUnavailableException e) {
-//            e.printStackTrace();
-//        }
-//        User_Name_Label = new JLabel("ID");
-//        User_Name_Label.setBounds(10, 20, 80, 25);
-//        UseNameText = new JTextField(20);
-//        UseNameText.setBounds(150, 20, 165, 25);
-//        panel.add(User_Name_Label);
-//        panel.add(UseNameText);
-//        validate();
-    }
-    public void paint(Graphics g)
-    {
-        im=this.createImage(w,h);
-        gra=im.getGraphics();
-        paintComponents(gra);
-        g.drawImage(im,0,0,this);
-    }
-    public void paintComponents(Graphics g)
-    {
-        super.paintComponents(g);
-        pokemon=new ImageIcon("C://Users// //IdeaProjects//OOP_EX2//src//gameClient//files//ash.jpg");
-        Image pokemon1 = pokemon.getImage();
-        Image pokemon2 = pokemon1.getScaledInstance(w, h,Image.SCALE_DEFAULT);
-        pokemon=new ImageIcon(pokemon2);
-        pokemon.paintIcon(this, g, 0,0);
-
-      //  panel2.setBackground(new Color(0,0,0,80));
-//        User_Name_Label = new JLabel("ID");
-//        User_Name_Label.setBounds(10, 20, 80, 25);
-//        UseNameText = new JTextField(20);
-//        UseNameText.setBounds(150, 20, 165, 25);
-//        panel.add(User_Name_Label);
-//        panel.add(UseNameText);
-
-//        Font font = new Font("BN Loco", Font.PLAIN, 20);
-//        g.setFont(font);
-//        g.drawRect(10, 20, 200, 100);
-//        g.drawString("Login success", 10, 20);
-    }
-
-    public void playMusic() throws IOException, UnsupportedAudioFileException, LineUnavailableException {
-        File musicPath =new File("C:/Users/ /IdeaProjects/OOP_EX2/src/gameClient/pokemon_song.wav");
-        AudioInputStream audioInput = AudioSystem.getAudioInputStream(musicPath);
-        Clip clip=AudioSystem.getClip();
-        clip.open(audioInput);
-        clip.start();
-    }
-}
Index: out/production/OOP_EX2/annotations-13.0.jar/META-INF/maven/org.jetbrains/annotations/pom.properties
===================================================================
--- out/production/OOP_EX2/annotations-13.0.jar/META-INF/maven/org.jetbrains/annotations/pom.properties	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/annotations-13.0.jar/META-INF/maven/org.jetbrains/annotations/pom.properties	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,5 +0,0 @@
-#Generated by Maven
-#Tue Dec 17 16:10:35 MSK 2013
-version=13.0
-groupId=org.jetbrains
-artifactId=annotations
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONTokener.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONTokener.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONTokener.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,445 +0,0 @@
-package org.json;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringReader;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-/**
- * A JSONTokener takes a source string and extracts characters and tokens from
- * it. It is used by the JSONObject and JSONArray constructors to parse
- * JSON source strings.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class JSONTokener {
-
-    private int 	character;
-	private boolean eof;
-    private int 	index;
-    private int 	line;
-    private char 	previous;
-    private Reader 	reader;
-    private boolean usePrevious;
-
-
-    /**
-     * Construct a JSONTokener from a Reader.
-     *
-     * @param reader     A reader.
-     */
-    public JSONTokener(Reader reader) {
-        this.reader = reader.markSupported() ? 
-        		reader : new BufferedReader(reader);
-        this.eof = false;
-        this.usePrevious = false;
-        this.previous = 0;
-        this.index = 0;
-        this.character = 1;
-        this.line = 1;
-    }
-    
-    
-    /**
-     * Construct a JSONTokener from an InputStream.
-     */
-    public JSONTokener(InputStream inputStream) throws JSONException {
-        this(new InputStreamReader(inputStream));    	
-    }
-
-
-    /**
-     * Construct a JSONTokener from a string.
-     *
-     * @param s     A source string.
-     */
-    public JSONTokener(String s) {
-        this(new StringReader(s));
-    }
-
-
-    /**
-     * Back up one character. This provides a sort of lookahead capability,
-     * so that you can test for a digit or letter before attempting to parse
-     * the next number or identifier.
-     */
-    public void back() throws JSONException {
-        if (usePrevious || index <= 0) {
-            throw new JSONException("Stepping back two steps is not supported");
-        }
-        this.index -= 1;
-        this.character -= 1;
-        this.usePrevious = true;
-        this.eof = false;
-    }
-
-
-    /**
-     * Get the hex value of a character (base16).
-     * @param c A character between '0' and '9' or between 'A' and 'F' or
-     * between 'a' and 'f'.
-     * @return  An int between 0 and 15, or -1 if c was not a hex digit.
-     */
-    public static int dehexchar(char c) {
-        if (c >= '0' && c <= '9') {
-            return c - '0';
-        }
-        if (c >= 'A' && c <= 'F') {
-            return c - ('A' - 10);
-        }
-        if (c >= 'a' && c <= 'f') {
-            return c - ('a' - 10);
-        }
-        return -1;
-    }
-    
-    public boolean end() {
-    	return eof && !usePrevious;    	
-    }
-
-
-    /**
-     * Determine if the source string still contains characters that next()
-     * can consume.
-     * @return true if not yet at the end of the source.
-     */
-    public boolean more() throws JSONException {
-        next();
-        if (end()) {
-            return false;
-        } 
-        back();
-        return true;
-    }
-
-
-    /**
-     * Get the next character in the source string.
-     *
-     * @return The next character, or 0 if past the end of the source string.
-     */
-    public char next() throws JSONException {
-        int c;
-        if (this.usePrevious) {
-        	this.usePrevious = false;
-            c = this.previous;
-        } else {
-	        try {
-	            c = this.reader.read();
-	        } catch (IOException exception) {
-	            throw new JSONException(exception);
-	        }
-	
-	        if (c <= 0) { // End of stream
-	        	this.eof = true;
-	        	c = 0;
-	        } 
-        }
-    	this.index += 1;
-    	if (this.previous == '\r') {
-    		this.line += 1;
-    		this.character = c == '\n' ? 0 : 1;
-    	} else if (c == '\n') {
-    		this.line += 1;
-    		this.character = 0;
-    	} else {
-    		this.character += 1;
-    	}
-    	this.previous = (char) c;
-        return this.previous;
-    }
-
-
-    /**
-     * Consume the next character, and check that it matches a specified
-     * character.
-     * @param c The character to match.
-     * @return The character.
-     * @throws JSONException if the character does not match.
-     */
-    public char next(char c) throws JSONException {
-        char n = next();
-        if (n != c) {
-            throw syntaxError("Expected '" + c + "' and instead saw '" +
-                    n + "'");
-        }
-        return n;
-    }
-
-
-    /**
-     * Get the next n characters.
-     *
-     * @param n     The number of characters to take.
-     * @return      A string of n characters.
-     * @throws JSONException
-     *   Substring bounds error if there are not
-     *   n characters remaining in the source string.
-     */
-     public String next(int n) throws JSONException {
-         if (n == 0) {
-             return "";
-         }
-
-         char[] chars = new char[n];
-         int pos = 0;
-
-         while (pos < n) {
-             chars[pos] = next();
-             if (end()) {
-                 throw syntaxError("Substring bounds error");                 
-             }
-             pos += 1;
-         }
-         return new String(chars);
-     }
-
-
-    /**
-     * Get the next char in the string, skipping whitespace.
-     * @throws JSONException
-     * @return  A character, or 0 if there are no more characters.
-     */
-    public char nextClean() throws JSONException {
-        for (;;) {
-            char c = next();
-            if (c == 0 || c > ' ') {
-                return c;
-            }
-        }
-    }
-
-
-    /**
-     * Return the characters up to the next close quote character.
-     * Backslash processing is done. The formal JSON format does not
-     * allow strings in single quotes, but an implementation is allowed to
-     * accept them.
-     * @param quote The quoting character, either
-     *      <code>"</code>&nbsp;<small>(double quote)</small> or
-     *      <code>'</code>&nbsp;<small>(single quote)</small>.
-     * @return      A String.
-     * @throws JSONException Unterminated string.
-     */
-    public String nextString(char quote) throws JSONException {
-        char c;
-        StringBuffer sb = new StringBuffer();
-        for (;;) {
-            c = next();
-            switch (c) {
-            case 0:
-            case '\n':
-            case '\r':
-                throw syntaxError("Unterminated string");
-            case '\\':
-                c = next();
-                switch (c) {
-                case 'b':
-                    sb.append('\b');
-                    break;
-                case 't':
-                    sb.append('\t');
-                    break;
-                case 'n':
-                    sb.append('\n');
-                    break;
-                case 'f':
-                    sb.append('\f');
-                    break;
-                case 'r':
-                    sb.append('\r');
-                    break;
-                case 'u':
-                    sb.append((char)Integer.parseInt(next(4), 16));
-                    break;
-                case '"':
-                case '\'':
-                case '\\':
-                case '/':
-                	sb.append(c);
-                	break;
-                default:
-                    throw syntaxError("Illegal escape.");
-                }
-                break;
-            default:
-                if (c == quote) {
-                    return sb.toString();
-                }
-                sb.append(c);
-            }
-        }
-    }
-
-
-    /**
-     * Get the text up but not including the specified character or the
-     * end of line, whichever comes first.
-     * @param  delimiter A delimiter character.
-     * @return   A string.
-     */
-    public String nextTo(char delimiter) throws JSONException {
-        StringBuffer sb = new StringBuffer();
-        for (;;) {
-            char c = next();
-            if (c == delimiter || c == 0 || c == '\n' || c == '\r') {
-                if (c != 0) {
-                    back();
-                }
-                return sb.toString().trim();
-            }
-            sb.append(c);
-        }
-    }
-
-
-    /**
-     * Get the text up but not including one of the specified delimiter
-     * characters or the end of line, whichever comes first.
-     * @param delimiters A set of delimiter characters.
-     * @return A string, trimmed.
-     */
-    public String nextTo(String delimiters) throws JSONException {
-        char c;
-        StringBuffer sb = new StringBuffer();
-        for (;;) {
-            c = next();
-            if (delimiters.indexOf(c) >= 0 || c == 0 ||
-                    c == '\n' || c == '\r') {
-                if (c != 0) {
-                    back();
-                }
-                return sb.toString().trim();
-            }
-            sb.append(c);
-        }
-    }
-
-
-    /**
-     * Get the next value. The value can be a Boolean, Double, Integer,
-     * JSONArray, JSONObject, Long, or String, or the JSONObject.NULL object.
-     * @throws JSONException If syntax error.
-     *
-     * @return An object.
-     */
-    public Object nextValue() throws JSONException {
-        char c = nextClean();
-        String string;
-
-        switch (c) {
-            case '"':
-            case '\'':
-                return nextString(c);
-            case '{':
-                back();
-                return new JSONObject(this);
-            case '[':
-                back();
-                return new JSONArray(this);
-        }
-
-        /*
-         * Handle unquoted text. This could be the values true, false, or
-         * null, or it can be a number. An implementation (such as this one)
-         * is allowed to also accept non-standard forms.
-         *
-         * Accumulate characters until we reach the end of the text or a
-         * formatting character.
-         */
-
-        StringBuffer sb = new StringBuffer();
-        while (c >= ' ' && ",:]}/\\\"[{;=#".indexOf(c) < 0) {
-            sb.append(c);
-            c = next();
-        }
-        back();
-
-        string = sb.toString().trim();
-        if (string.equals("")) {
-            throw syntaxError("Missing value");
-        }
-        return JSONObject.stringToValue(string);
-    }
-
-
-    /**
-     * Skip characters until the next character is the requested character.
-     * If the requested character is not found, no characters are skipped.
-     * @param to A character to skip to.
-     * @return The requested character, or zero if the requested character
-     * is not found.
-     */
-    public char skipTo(char to) throws JSONException {
-        char c;
-        try {
-            int startIndex = this.index;
-            int startCharacter = this.character;
-            int startLine = this.line;
-            reader.mark(Integer.MAX_VALUE);
-            do {
-                c = next();
-                if (c == 0) {
-                    reader.reset();
-                    this.index = startIndex;
-                    this.character = startCharacter;
-                    this.line = startLine;
-                    return c;
-                }
-            } while (c != to);
-        } catch (IOException exc) {
-            throw new JSONException(exc);
-        }
-
-        back();
-        return c;
-    }
-    
-
-    /**
-     * Make a JSONException to signal a syntax error.
-     *
-     * @param message The error message.
-     * @return  A JSONException object, suitable for throwing
-     */
-    public JSONException syntaxError(String message) {
-        return new JSONException(message + toString());
-    }
-
-
-    /**
-     * Make a printable string of this JSONTokener.
-     *
-     * @return " at {index} [character {character} line {line}]"
-     */
-    public String toString() {
-        return " at " + index + " [character " + this.character + " line " + 
-        	this.line + "]";
-    }
-}
\ No newline at end of file
Index: out/production/OOP_EX2/java-json.jar/org/json/Cookie.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/Cookie.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/Cookie.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,169 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-/**
- * Convert a web browser cookie specification to a JSONObject and back.
- * JSON and Cookies are both notations for name/value pairs.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class Cookie {
-
-    /**
-     * Produce a copy of a string in which the characters '+', '%', '=', ';'
-     * and control characters are replaced with "%hh". This is a gentle form
-     * of URL encoding, attempting to cause as little distortion to the
-     * string as possible. The characters '=' and ';' are meta characters in
-     * cookies. By convention, they are escaped using the URL-encoding. This is
-     * only a convention, not a standard. Often, cookies are expected to have
-     * encoded values. We encode '=' and ';' because we must. We encode '%' and
-     * '+' because they are meta characters in URL encoding.
-     * @param string The source string.
-     * @return       The escaped result.
-     */
-    public static String escape(String string) {
-        char         c;
-        String       s = string.trim();
-        StringBuffer sb = new StringBuffer();
-        int          length = s.length();
-        for (int i = 0; i < length; i += 1) {
-            c = s.charAt(i);
-            if (c < ' ' || c == '+' || c == '%' || c == '=' || c == ';') {
-                sb.append('%');
-                sb.append(Character.forDigit((char)((c >>> 4) & 0x0f), 16));
-                sb.append(Character.forDigit((char)(c & 0x0f), 16));
-            } else {
-                sb.append(c);
-            }
-        }
-        return sb.toString();
-    }
-
-
-    /**
-     * Convert a cookie specification string into a JSONObject. The string
-     * will contain a name value pair separated by '='. The name and the value
-     * will be unescaped, possibly converting '+' and '%' sequences. The
-     * cookie properties may follow, separated by ';', also represented as
-     * name=value (except the secure property, which does not have a value).
-     * The name will be stored under the key "name", and the value will be
-     * stored under the key "value". This method does not do checking or
-     * validation of the parameters. It only converts the cookie string into
-     * a JSONObject.
-     * @param string The cookie specification string.
-     * @return A JSONObject containing "name", "value", and possibly other
-     *  members.
-     * @throws JSONException
-     */
-    public static JSONObject toJSONObject(String string) throws JSONException {
-        String         name;
-        JSONObject     jo = new JSONObject();
-        Object         value;
-        JSONTokener x = new JSONTokener(string);
-        jo.put("name", x.nextTo('='));
-        x.next('=');
-        jo.put("value", x.nextTo(';'));
-        x.next();
-        while (x.more()) {
-            name = unescape(x.nextTo("=;"));
-            if (x.next() != '=') {
-                if (name.equals("secure")) {
-                    value = Boolean.TRUE;
-                } else {
-                    throw x.syntaxError("Missing '=' in cookie parameter.");
-                }
-            } else {
-                value = unescape(x.nextTo(';'));
-                x.next();
-            }
-            jo.put(name, value);
-        }
-        return jo;
-    }
-
-
-    /**
-     * Convert a JSONObject into a cookie specification string. The JSONObject
-     * must contain "name" and "value" members.
-     * If the JSONObject contains "expires", "domain", "path", or "secure"
-     * members, they will be appended to the cookie specification string.
-     * All other members are ignored.
-     * @param jo A JSONObject
-     * @return A cookie specification string
-     * @throws JSONException
-     */
-    public static String toString(JSONObject jo) throws JSONException {
-        StringBuffer sb = new StringBuffer();
-
-        sb.append(escape(jo.getString("name")));
-        sb.append("=");
-        sb.append(escape(jo.getString("value")));
-        if (jo.has("expires")) {
-            sb.append(";expires=");
-            sb.append(jo.getString("expires"));
-        }
-        if (jo.has("domain")) {
-            sb.append(";domain=");
-            sb.append(escape(jo.getString("domain")));
-        }
-        if (jo.has("path")) {
-            sb.append(";path=");
-            sb.append(escape(jo.getString("path")));
-        }
-        if (jo.optBoolean("secure")) {
-            sb.append(";secure");
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Convert <code>%</code><i>hh</i> sequences to single characters, and
-     * convert plus to space.
-     * @param string A string that may contain
-     *      <code>+</code>&nbsp;<small>(plus)</small> and
-     *      <code>%</code><i>hh</i> sequences.
-     * @return The unescaped string.
-     */
-    public static String unescape(String string) {
-        int length = string.length();
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < length; ++i) {
-            char c = string.charAt(i);
-            if (c == '+') {
-                c = ' ';
-            } else if (c == '%' && i + 2 < length) {
-                int d = JSONTokener.dehexchar(string.charAt(i + 1));
-                int e = JSONTokener.dehexchar(string.charAt(i + 2));
-                if (d >= 0 && e >= 0) {
-                    c = (char)(d * 16 + e);
-                    i += 2;
-                }
-            }
-            sb.append(c);
-        }
-        return sb.toString();
-    }
-}
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONObject.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONObject.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONObject.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,1632 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Method;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Locale;
-import java.util.Map;
-import java.util.ResourceBundle;
-
-/**
- * A JSONObject is an unordered collection of name/value pairs. Its
- * external form is a string wrapped in curly braces with colons between the
- * names and values, and commas between the values and names. The internal form
- * is an object having <code>get</code> and <code>opt</code> methods for
- * accessing the values by name, and <code>put</code> methods for adding or
- * replacing values by name. The values can be any of these types:
- * <code>Boolean</code>, <code>JSONArray</code>, <code>JSONObject</code>,
- * <code>Number</code>, <code>String</code>, or the <code>JSONObject.NULL</code>
- * object. A JSONObject constructor can be used to convert an external form
- * JSON text into an internal form whose values can be retrieved with the
- * <code>get</code> and <code>opt</code> methods, or to convert values into a
- * JSON text using the <code>put</code> and <code>toString</code> methods.
- * A <code>get</code> method returns a value if one can be found, and throws an
- * exception if one cannot be found. An <code>opt</code> method returns a
- * default value instead of throwing an exception, and so is useful for
- * obtaining optional values.
- * <p>
- * The generic <code>get()</code> and <code>opt()</code> methods return an
- * object, which you can cast or query for type. There are also typed
- * <code>get</code> and <code>opt</code> methods that do type checking and type
- * coercion for you. The opt methods differ from the get methods in that they
- * do not throw. Instead, they return a specified value, such as null.
- * <p>
- * The <code>put</code> methods add or replace values in an object. For example, 
- * <pre>myString = new JSONObject().put("JSON", "Hello, World!").toString();</pre>
- * produces the string <code>{"JSON": "Hello, World"}</code>.
- * <p>
- * The texts produced by the <code>toString</code> methods strictly conform to
- * the JSON syntax rules.
- * The constructors are more forgiving in the texts they will accept:
- * <ul>
- * <li>An extra <code>,</code>&nbsp;<small>(comma)</small> may appear just
- *     before the closing brace.</li>
- * <li>Strings may be quoted with <code>'</code>&nbsp;<small>(single
- *     quote)</small>.</li>
- * <li>Strings do not need to be quoted at all if they do not begin with a quote
- *     or single quote, and if they do not contain leading or trailing spaces,
- *     and if they do not contain any of these characters:
- *     <code>{ } [ ] / \ : , = ; #</code> and if they do not look like numbers
- *     and if they are not the reserved words <code>true</code>,
- *     <code>false</code>, or <code>null</code>.</li>
- * <li>Keys can be followed by <code>=</code> or <code>=></code> as well as
- *     by <code>:</code>.</li>
- * <li>Values can be followed by <code>;</code> <small>(semicolon)</small> as
- *     well as by <code>,</code> <small>(comma)</small>.</li>
- * <li>Numbers may have the <code>0x-</code> <small>(hex)</small> prefix.</li>
- * </ul>
- * @author JSON.org
- * @version 2011-04-05
- */
-public class JSONObject {
-
-    /**
-     * JSONObject.NULL is equivalent to the value that JavaScript calls null,
-     * whilst Java's null is equivalent to the value that JavaScript calls
-     * undefined.
-     */
-     private static final class Null {
-
-        /**
-         * There is only intended to be a single instance of the NULL object,
-         * so the clone method returns itself.
-         * @return     NULL.
-         */
-        protected final Object clone() {
-            return this;
-        }
-
-        /**
-         * A Null object is equal to the null value and to itself.
-         * @param object    An object to test for nullness.
-         * @return true if the object parameter is the JSONObject.NULL object
-         *  or null.
-         */
-        public boolean equals(Object object) {
-            return object == null || object == this;
-        }
-
-        /**
-         * Get the "null" string value.
-         * @return The string "null".
-         */
-        public String toString() {
-            return "null";
-        }
-    }
-
-
-    /**
-     * The map where the JSONObject's properties are kept.
-     */
-    private Map map;
-
-
-    /**
-     * It is sometimes more convenient and less ambiguous to have a
-     * <code>NULL</code> object than to use Java's <code>null</code> value.
-     * <code>JSONObject.NULL.equals(null)</code> returns <code>true</code>.
-     * <code>JSONObject.NULL.toString()</code> returns <code>"null"</code>.
-     */
-    public static final Object NULL = new Null();
-
-
-    /**
-     * Construct an empty JSONObject.
-     */
-    public JSONObject() {
-        this.map = new HashMap();
-    }
-
-
-    /**
-     * Construct a JSONObject from a subset of another JSONObject.
-     * An array of strings is used to identify the keys that should be copied.
-     * Missing keys are ignored.
-     * @param jo A JSONObject.
-     * @param names An array of strings.
-     * @throws JSONException 
-     * @exception JSONException If a value is a non-finite number or if a name is duplicated.
-     */
-    public JSONObject(JSONObject jo, String[] names) {
-        this();
-        for (int i = 0; i < names.length; i += 1) {
-            try {
-                putOnce(names[i], jo.opt(names[i]));
-            } catch (Exception ignore) {
-            }
-        }
-    }
-
-
-    /**
-     * Construct a JSONObject from a JSONTokener.
-     * @param x A JSONTokener object containing the source string.
-     * @throws JSONException If there is a syntax error in the source string
-     *  or a duplicated key.
-     */
-    public JSONObject(JSONTokener x) throws JSONException {
-        this();
-        char c;
-        String key;
-
-        if (x.nextClean() != '{') {
-            throw x.syntaxError("A JSONObject text must begin with '{'");
-        }
-        for (;;) {
-            c = x.nextClean();
-            switch (c) {
-            case 0:
-                throw x.syntaxError("A JSONObject text must end with '}'");
-            case '}':
-                return;
-            default:
-                x.back();
-                key = x.nextValue().toString();
-            }
-
-// The key is followed by ':'. We will also tolerate '=' or '=>'.
-
-            c = x.nextClean();
-            if (c == '=') {
-                if (x.next() != '>') {
-                    x.back();
-                }
-            } else if (c != ':') {
-                throw x.syntaxError("Expected a ':' after a key");
-            }
-            putOnce(key, x.nextValue());
-
-// Pairs are separated by ','. We will also tolerate ';'.
-
-            switch (x.nextClean()) {
-            case ';':
-            case ',':
-                if (x.nextClean() == '}') {
-                    return;
-                }
-                x.back();
-                break;
-            case '}':
-                return;
-            default:
-                throw x.syntaxError("Expected a ',' or '}'");
-            }
-        }
-    }
-
-
-    /**
-     * Construct a JSONObject from a Map.
-     *
-     * @param map A map object that can be used to initialize the contents of
-     *  the JSONObject.
-     * @throws JSONException 
-     */
-    public JSONObject(Map map) {
-        this.map = new HashMap();
-        if (map != null) {
-            Iterator i = map.entrySet().iterator();
-            while (i.hasNext()) {
-                Map.Entry e = (Map.Entry)i.next();
-                Object value = e.getValue();
-                if (value != null) {
-                    this.map.put(e.getKey(), wrap(value));
-                }
-            }
-        }
-    }
-
-
-    /**
-     * Construct a JSONObject from an Object using bean getters.
-     * It reflects on all of the public methods of the object.
-     * For each of the methods with no parameters and a name starting
-     * with <code>"get"</code> or <code>"is"</code> followed by an uppercase letter,
-     * the method is invoked, and a key and the value returned from the getter method
-     * are put into the new JSONObject.
-     *
-     * The key is formed by removing the <code>"get"</code> or <code>"is"</code> prefix.
-     * If the second remaining character is not upper case, then the first
-     * character is converted to lower case.
-     *
-     * For example, if an object has a method named <code>"getName"</code>, and
-     * if the result of calling <code>object.getName()</code> is <code>"Larry Fine"</code>,
-     * then the JSONObject will contain <code>"name": "Larry Fine"</code>.
-     *
-     * @param bean An object that has getter methods that should be used
-     * to make a JSONObject.
-     */
-    public JSONObject(Object bean) {
-        this();
-        populateMap(bean);
-    }
-
-
-    /**
-     * Construct a JSONObject from an Object, using reflection to find the
-     * public members. The resulting JSONObject's keys will be the strings
-     * from the names array, and the values will be the field values associated
-     * with those keys in the object. If a key is not found or not visible,
-     * then it will not be copied into the new JSONObject.
-     * @param object An object that has fields that should be used to make a
-     * JSONObject.
-     * @param names An array of strings, the names of the fields to be obtained
-     * from the object.
-     */
-    public JSONObject(Object object, String names[]) {
-        this();
-        Class c = object.getClass();
-        for (int i = 0; i < names.length; i += 1) {
-            String name = names[i];
-            try {
-                putOpt(name, c.getField(name).get(object));
-            } catch (Exception ignore) {
-            }
-        }
-    }
-
-
-    /**
-     * Construct a JSONObject from a source JSON text string.
-     * This is the most commonly used JSONObject constructor.
-     * @param source    A string beginning
-     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
-     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
-     * @exception JSONException If there is a syntax error in the source
-     *  string or a duplicated key.
-     */
-    public JSONObject(String source) throws JSONException {
-        this(new JSONTokener(source));
-    }
-
-
-    /**
-     * Construct a JSONObject from a ResourceBundle.
-     * @param baseName The ResourceBundle base name.
-     * @param locale The Locale to load the ResourceBundle for.
-     * @throws JSONException If any JSONExceptions are detected.
-     */
-    public JSONObject(String baseName, Locale locale) throws JSONException {
-        this();
-        ResourceBundle bundle = ResourceBundle.getBundle(baseName, locale, 
-                Thread.currentThread().getContextClassLoader());
-
-// Iterate through the keys in the bundle.
-        
-        Enumeration keys = bundle.getKeys();
-        while (keys.hasMoreElements()) {
-            Object key = keys.nextElement();
-            if (key instanceof String) {
-    
-// Go through the path, ensuring that there is a nested JSONObject for each 
-// segment except the last. Add the value using the last segment's name into
-// the deepest nested JSONObject.
-                
-                String[] path = ((String)key).split("\\.");
-                int last = path.length - 1;
-                JSONObject target = this;
-                for (int i = 0; i < last; i += 1) {
-                    String segment = path[i];
-                    JSONObject nextTarget = target.optJSONObject(segment);
-                    if (nextTarget == null) {
-                        nextTarget = new JSONObject();
-                        target.put(segment, nextTarget);
-                    }
-                    target = nextTarget;
-                }
-                target.put(path[last], bundle.getString((String)key));
-            }
-        }
-    }
-
-    
-    /**
-     * Accumulate values under a key. It is similar to the put method except
-     * that if there is already an object stored under the key then a
-     * JSONArray is stored under the key to hold all of the accumulated values.
-     * If there is already a JSONArray, then the new value is appended to it.
-     * In contrast, the put method replaces the previous value.
-     * 
-     * If only one value is accumulated that is not a JSONArray, then the
-     * result will be the same as using put. But if multiple values are 
-     * accumulated, then the result will be like append.
-     * @param key   A key string.
-     * @param value An object to be accumulated under the key.
-     * @return this.
-     * @throws JSONException If the value is an invalid number
-     *  or if the key is null.
-     */
-    public JSONObject accumulate(
-        String key, 
-        Object value
-    ) throws JSONException {
-        testValidity(value);
-        Object object = opt(key);
-        if (object == null) {
-            put(key, value instanceof JSONArray ?
-                    new JSONArray().put(value) : value);
-        } else if (object instanceof JSONArray) {
-            ((JSONArray)object).put(value);
-        } else {
-            put(key, new JSONArray().put(object).put(value));
-        }
-        return this;
-    }
-
-
-    /**
-     * Append values to the array under a key. If the key does not exist in the
-     * JSONObject, then the key is put in the JSONObject with its value being a
-     * JSONArray containing the value parameter. If the key was already
-     * associated with a JSONArray, then the value parameter is appended to it.
-     * @param key   A key string.
-     * @param value An object to be accumulated under the key.
-     * @return this.
-     * @throws JSONException If the key is null or if the current value
-     *  associated with the key is not a JSONArray.
-     */
-    public JSONObject append(String key, Object value) throws JSONException {
-        testValidity(value);
-        Object object = opt(key);
-        if (object == null) {
-            put(key, new JSONArray().put(value));
-        } else if (object instanceof JSONArray) {
-            put(key, ((JSONArray)object).put(value));
-        } else {
-            throw new JSONException("JSONObject[" + key +
-                    "] is not a JSONArray.");
-        }
-        return this;
-    }
-
-
-    /**
-     * Produce a string from a double. The string "null" will be returned if
-     * the number is not finite.
-     * @param  d A double.
-     * @return A String.
-     */
-    public static String doubleToString(double d) {
-        if (Double.isInfinite(d) || Double.isNaN(d)) {
-            return "null";
-        }
-
-// Shave off trailing zeros and decimal point, if possible.
-
-        String string = Double.toString(d);
-        if (string.indexOf('.') > 0 && string.indexOf('e') < 0 && 
-        		string.indexOf('E') < 0) {
-            while (string.endsWith("0")) {
-                string = string.substring(0, string.length() - 1);
-            }
-            if (string.endsWith(".")) {
-                string = string.substring(0, string.length() - 1);
-            }
-        }
-        return string;
-    }
-
-
-    /**
-     * Get the value object associated with a key.
-     *
-     * @param key   A key string.
-     * @return      The object associated with the key.
-     * @throws      JSONException if the key is not found.
-     */
-    public Object get(String key) throws JSONException {
-        if (key == null) {
-            throw new JSONException("Null key.");
-        }
-        Object object = opt(key);
-        if (object == null) {
-            throw new JSONException("JSONObject[" + quote(key) +
-                    "] not found.");
-        }
-        return object;
-    }
-
-
-    /**
-     * Get the boolean value associated with a key.
-     *
-     * @param key   A key string.
-     * @return      The truth.
-     * @throws      JSONException
-     *  if the value is not a Boolean or the String "true" or "false".
-     */
-    public boolean getBoolean(String key) throws JSONException {
-        Object object = get(key);
-        if (object.equals(Boolean.FALSE) ||
-                (object instanceof String &&
-                ((String)object).equalsIgnoreCase("false"))) {
-            return false;
-        } else if (object.equals(Boolean.TRUE) ||
-                (object instanceof String &&
-                ((String)object).equalsIgnoreCase("true"))) {
-            return true;
-        }
-        throw new JSONException("JSONObject[" + quote(key) +
-                "] is not a Boolean.");
-    }
-
-
-    /**
-     * Get the double value associated with a key.
-     * @param key   A key string.
-     * @return      The numeric value.
-     * @throws JSONException if the key is not found or
-     *  if the value is not a Number object and cannot be converted to a number.
-     */
-    public double getDouble(String key) throws JSONException {
-        Object object = get(key);
-        try {
-            return object instanceof Number ?
-                ((Number)object).doubleValue() :
-                Double.parseDouble((String)object);
-        } catch (Exception e) {
-            throw new JSONException("JSONObject[" + quote(key) +
-                "] is not a number.");
-        }
-    }
-
-
-    /**
-     * Get the int value associated with a key. 
-     *
-     * @param key   A key string.
-     * @return      The integer value.
-     * @throws   JSONException if the key is not found or if the value cannot
-     *  be converted to an integer.
-     */
-    public int getInt(String key) throws JSONException {
-        Object object = get(key);
-        try {
-            return object instanceof Number ?
-                ((Number)object).intValue() :
-                Integer.parseInt((String)object);
-        } catch (Exception e) {
-            throw new JSONException("JSONObject[" + quote(key) +
-                "] is not an int.");
-        }
-    }
-
-
-    /**
-     * Get the JSONArray value associated with a key.
-     *
-     * @param key   A key string.
-     * @return      A JSONArray which is the value.
-     * @throws      JSONException if the key is not found or
-     *  if the value is not a JSONArray.
-     */
-    public JSONArray getJSONArray(String key) throws JSONException {
-        Object object = get(key);
-        if (object instanceof JSONArray) {
-            return (JSONArray)object;
-        }
-        throw new JSONException("JSONObject[" + quote(key) +
-                "] is not a JSONArray.");
-    }
-
-
-    /**
-     * Get the JSONObject value associated with a key.
-     *
-     * @param key   A key string.
-     * @return      A JSONObject which is the value.
-     * @throws      JSONException if the key is not found or
-     *  if the value is not a JSONObject.
-     */
-    public JSONObject getJSONObject(String key) throws JSONException {
-        Object object = get(key);
-        if (object instanceof JSONObject) {
-            return (JSONObject)object;
-        }
-        throw new JSONException("JSONObject[" + quote(key) +
-                "] is not a JSONObject.");
-    }
-
-
-    /**
-     * Get the long value associated with a key. 
-     *
-     * @param key   A key string.
-     * @return      The long value.
-     * @throws   JSONException if the key is not found or if the value cannot
-     *  be converted to a long.
-     */
-    public long getLong(String key) throws JSONException {
-        Object object = get(key);
-        try {
-            return object instanceof Number ?
-                ((Number)object).longValue() :
-                Long.parseLong((String)object);
-        } catch (Exception e) {
-            throw new JSONException("JSONObject[" + quote(key) +
-                "] is not a long.");
-        }
-    }
-
-
-    /**
-     * Get an array of field names from a JSONObject.
-     *
-     * @return An array of field names, or null if there are no names.
-     */
-    public static String[] getNames(JSONObject jo) {
-        int length = jo.length();
-        if (length == 0) {
-            return null;
-        }
-        Iterator iterator = jo.keys();
-        String[] names = new String[length];
-        int i = 0;
-        while (iterator.hasNext()) {
-            names[i] = (String)iterator.next();
-            i += 1;
-        }
-        return names;
-    }
-
-
-    /**
-     * Get an array of field names from an Object.
-     *
-     * @return An array of field names, or null if there are no names.
-     */
-    public static String[] getNames(Object object) {
-        if (object == null) {
-            return null;
-        }
-        Class klass = object.getClass();
-        Field[] fields = klass.getFields();
-        int length = fields.length;
-        if (length == 0) {
-            return null;
-        }
-        String[] names = new String[length];
-        for (int i = 0; i < length; i += 1) {
-            names[i] = fields[i].getName();
-        }
-        return names;
-    }
-
-
-    /**
-     * Get the string associated with a key.
-     *
-     * @param key   A key string.
-     * @return      A string which is the value.
-     * @throws   JSONException if there is no string value for the key.
-     */
-    public String getString(String key) throws JSONException {
-        Object object = get(key);
-        if (object instanceof String) {
-            return (String)object;
-        }
-        throw new JSONException("JSONObject[" + quote(key) +
-            "] not a string.");
-    }
-
-
-    /**
-     * Determine if the JSONObject contains a specific key.
-     * @param key   A key string.
-     * @return      true if the key exists in the JSONObject.
-     */
-    public boolean has(String key) {
-        return this.map.containsKey(key);
-    }
-    
-    
-    /**
-     * Increment a property of a JSONObject. If there is no such property,
-     * create one with a value of 1. If there is such a property, and if
-     * it is an Integer, Long, Double, or Float, then add one to it.
-     * @param key  A key string.
-     * @return this.
-     * @throws JSONException If there is already a property with this name
-     * that is not an Integer, Long, Double, or Float.
-     */
-    public JSONObject increment(String key) throws JSONException {
-        Object value = opt(key);
-        if (value == null) {
-            put(key, 1);
-        } else if (value instanceof Integer) {
-            put(key, ((Integer)value).intValue() + 1);
-        } else if (value instanceof Long) {
-            put(key, ((Long)value).longValue() + 1);                
-        } else if (value instanceof Double) {
-            put(key, ((Double)value).doubleValue() + 1);                
-        } else if (value instanceof Float) {
-            put(key, ((Float)value).floatValue() + 1);                
-        } else {
-            throw new JSONException("Unable to increment [" + quote(key) + "].");
-        }
-        return this;
-    }
-
-
-    /**
-     * Determine if the value associated with the key is null or if there is
-     *  no value.
-     * @param key   A key string.
-     * @return      true if there is no value associated with the key or if
-     *  the value is the JSONObject.NULL object.
-     */
-    public boolean isNull(String key) {
-        return JSONObject.NULL.equals(opt(key));
-    }
-
-
-    /**
-     * Get an enumeration of the keys of the JSONObject.
-     *
-     * @return An iterator of the keys.
-     */
-    public Iterator keys() {
-        return this.map.keySet().iterator();
-    }
-
-
-    /**
-     * Get the number of keys stored in the JSONObject.
-     *
-     * @return The number of keys in the JSONObject.
-     */
-    public int length() {
-        return this.map.size();
-    }
-
-
-    /**
-     * Produce a JSONArray containing the names of the elements of this
-     * JSONObject.
-     * @return A JSONArray containing the key strings, or null if the JSONObject
-     * is empty.
-     */
-    public JSONArray names() {
-        JSONArray ja = new JSONArray();
-        Iterator  keys = this.keys();
-        while (keys.hasNext()) {
-            ja.put(keys.next());
-        }
-        return ja.length() == 0 ? null : ja;
-    }
-
-    /**
-     * Produce a string from a Number.
-     * @param  number A Number
-     * @return A String.
-     * @throws JSONException If n is a non-finite number.
-     */
-    public static String numberToString(Number number)
-            throws JSONException {
-        if (number == null) {
-            throw new JSONException("Null pointer");
-        }
-        testValidity(number);
-
-// Shave off trailing zeros and decimal point, if possible.
-
-        String string = number.toString();
-        if (string.indexOf('.') > 0 && string.indexOf('e') < 0 && 
-        		string.indexOf('E') < 0) {
-            while (string.endsWith("0")) {
-                string = string.substring(0, string.length() - 1);
-            }
-            if (string.endsWith(".")) {
-                string = string.substring(0, string.length() - 1);
-            }
-        }
-        return string;
-    }
-
-
-    /**
-     * Get an optional value associated with a key.
-     * @param key   A key string.
-     * @return      An object which is the value, or null if there is no value.
-     */
-    public Object opt(String key) {
-        return key == null ? null : this.map.get(key);
-    }
-
-
-    /**
-     * Get an optional boolean associated with a key.
-     * It returns false if there is no such key, or if the value is not
-     * Boolean.TRUE or the String "true".
-     *
-     * @param key   A key string.
-     * @return      The truth.
-     */
-    public boolean optBoolean(String key) {
-        return optBoolean(key, false);
-    }
-
-
-    /**
-     * Get an optional boolean associated with a key.
-     * It returns the defaultValue if there is no such key, or if it is not
-     * a Boolean or the String "true" or "false" (case insensitive).
-     *
-     * @param key              A key string.
-     * @param defaultValue     The default.
-     * @return      The truth.
-     */
-    public boolean optBoolean(String key, boolean defaultValue) {
-        try {
-            return getBoolean(key);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get an optional double associated with a key,
-     * or NaN if there is no such key or if its value is not a number.
-     * If the value is a string, an attempt will be made to evaluate it as
-     * a number.
-     *
-     * @param key   A string which is the key.
-     * @return      An object which is the value.
-     */
-    public double optDouble(String key) {
-        return optDouble(key, Double.NaN);
-    }
-
-
-    /**
-     * Get an optional double associated with a key, or the
-     * defaultValue if there is no such key or if its value is not a number.
-     * If the value is a string, an attempt will be made to evaluate it as
-     * a number.
-     *
-     * @param key   A key string.
-     * @param defaultValue     The default.
-     * @return      An object which is the value.
-     */
-    public double optDouble(String key, double defaultValue) {
-        try {
-            return getDouble(key);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get an optional int value associated with a key,
-     * or zero if there is no such key or if the value is not a number.
-     * If the value is a string, an attempt will be made to evaluate it as
-     * a number.
-     *
-     * @param key   A key string.
-     * @return      An object which is the value.
-     */
-    public int optInt(String key) {
-        return optInt(key, 0);
-    }
-
-
-    /**
-     * Get an optional int value associated with a key,
-     * or the default if there is no such key or if the value is not a number.
-     * If the value is a string, an attempt will be made to evaluate it as
-     * a number.
-     *
-     * @param key   A key string.
-     * @param defaultValue     The default.
-     * @return      An object which is the value.
-     */
-    public int optInt(String key, int defaultValue) {
-        try {
-            return getInt(key);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get an optional JSONArray associated with a key.
-     * It returns null if there is no such key, or if its value is not a
-     * JSONArray.
-     *
-     * @param key   A key string.
-     * @return      A JSONArray which is the value.
-     */
-    public JSONArray optJSONArray(String key) {
-        Object o = opt(key);
-        return o instanceof JSONArray ? (JSONArray)o : null;
-    }
-
-
-    /**
-     * Get an optional JSONObject associated with a key.
-     * It returns null if there is no such key, or if its value is not a
-     * JSONObject.
-     *
-     * @param key   A key string.
-     * @return      A JSONObject which is the value.
-     */
-    public JSONObject optJSONObject(String key) {
-        Object object = opt(key);
-        return object instanceof JSONObject ? (JSONObject)object : null;
-    }
-
-
-    /**
-     * Get an optional long value associated with a key,
-     * or zero if there is no such key or if the value is not a number.
-     * If the value is a string, an attempt will be made to evaluate it as
-     * a number.
-     *
-     * @param key   A key string.
-     * @return      An object which is the value.
-     */
-    public long optLong(String key) {
-        return optLong(key, 0);
-    }
-
-
-    /**
-     * Get an optional long value associated with a key,
-     * or the default if there is no such key or if the value is not a number.
-     * If the value is a string, an attempt will be made to evaluate it as
-     * a number.
-     *
-     * @param key          A key string.
-     * @param defaultValue The default.
-     * @return             An object which is the value.
-     */
-    public long optLong(String key, long defaultValue) {
-        try {
-            return getLong(key);
-        } catch (Exception e) {
-            return defaultValue;
-        }
-    }
-
-
-    /**
-     * Get an optional string associated with a key.
-     * It returns an empty string if there is no such key. If the value is not
-     * a string and is not null, then it is converted to a string.
-     *
-     * @param key   A key string.
-     * @return      A string which is the value.
-     */
-    public String optString(String key) {
-        return optString(key, "");
-    }
-
-
-    /**
-     * Get an optional string associated with a key.
-     * It returns the defaultValue if there is no such key.
-     *
-     * @param key   A key string.
-     * @param defaultValue     The default.
-     * @return      A string which is the value.
-     */
-    public String optString(String key, String defaultValue) {
-        Object object = opt(key);
-        return NULL.equals(object) ? defaultValue : object.toString();        
-    }
-
-
-    private void populateMap(Object bean) {
-        Class klass = bean.getClass();
-
-// If klass is a System class then set includeSuperClass to false. 
-
-        boolean includeSuperClass = klass.getClassLoader() != null;
-
-        Method[] methods = (includeSuperClass) ?
-                klass.getMethods() : klass.getDeclaredMethods();
-        for (int i = 0; i < methods.length; i += 1) {
-            try {
-                Method method = methods[i];
-                if (Modifier.isPublic(method.getModifiers())) {
-                    String name = method.getName();
-                    String key = "";
-                    if (name.startsWith("get")) {
-                        if (name.equals("getClass") || 
-                                name.equals("getDeclaringClass")) {
-                            key = "";
-                        } else {
-                            key = name.substring(3);
-                        }
-                    } else if (name.startsWith("is")) {
-                        key = name.substring(2);
-                    }
-                    if (key.length() > 0 &&
-                            Character.isUpperCase(key.charAt(0)) &&
-                            method.getParameterTypes().length == 0) {
-                        if (key.length() == 1) {
-                            key = key.toLowerCase();
-                        } else if (!Character.isUpperCase(key.charAt(1))) {
-                            key = key.substring(0, 1).toLowerCase() +
-                                key.substring(1);
-                        }
-
-                        Object result = method.invoke(bean, (Object[])null);
-                        if (result != null) {
-                            map.put(key, wrap(result));
-                        }
-                    }
-                }
-            } catch (Exception ignore) {
-            }
-        }
-    }
-
-
-    /**
-     * Put a key/boolean pair in the JSONObject.
-     *
-     * @param key   A key string.
-     * @param value A boolean which is the value.
-     * @return this.
-     * @throws JSONException If the key is null.
-     */
-    public JSONObject put(String key, boolean value) throws JSONException {
-        put(key, value ? Boolean.TRUE : Boolean.FALSE);
-        return this;
-    }
-
-
-    /**
-     * Put a key/value pair in the JSONObject, where the value will be a
-     * JSONArray which is produced from a Collection.
-     * @param key   A key string.
-     * @param value A Collection value.
-     * @return      this.
-     * @throws JSONException
-     */
-    public JSONObject put(String key, Collection value) throws JSONException {
-        put(key, new JSONArray(value));
-        return this;
-    }
-
-
-    /**
-     * Put a key/double pair in the JSONObject.
-     *
-     * @param key   A key string.
-     * @param value A double which is the value.
-     * @return this.
-     * @throws JSONException If the key is null or if the number is invalid.
-     */
-    public JSONObject put(String key, double value) throws JSONException {
-        put(key, new Double(value));
-        return this;
-    }
-
-
-    /**
-     * Put a key/int pair in the JSONObject.
-     *
-     * @param key   A key string.
-     * @param value An int which is the value.
-     * @return this.
-     * @throws JSONException If the key is null.
-     */
-    public JSONObject put(String key, int value) throws JSONException {
-        put(key, new Integer(value));
-        return this;
-    }
-
-
-    /**
-     * Put a key/long pair in the JSONObject.
-     *
-     * @param key   A key string.
-     * @param value A long which is the value.
-     * @return this.
-     * @throws JSONException If the key is null.
-     */
-    public JSONObject put(String key, long value) throws JSONException {
-        put(key, new Long(value));
-        return this;
-    }
-
-
-    /**
-     * Put a key/value pair in the JSONObject, where the value will be a
-     * JSONObject which is produced from a Map.
-     * @param key   A key string.
-     * @param value A Map value.
-     * @return      this.
-     * @throws JSONException
-     */
-    public JSONObject put(String key, Map value) throws JSONException {
-        put(key, new JSONObject(value));
-        return this;
-    }
-
-
-    /**
-     * Put a key/value pair in the JSONObject. If the value is null,
-     * then the key will be removed from the JSONObject if it is present.
-     * @param key   A key string.
-     * @param value An object which is the value. It should be of one of these
-     *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
-     *  or the JSONObject.NULL object.
-     * @return this.
-     * @throws JSONException If the value is non-finite number
-     *  or if the key is null.
-     */
-    public JSONObject put(String key, Object value) throws JSONException {
-        if (key == null) {
-            throw new JSONException("Null key.");
-        }
-        if (value != null) {
-            testValidity(value);
-            this.map.put(key, value);
-        } else {
-            remove(key);
-        }
-        return this;
-    }
-
-
-    /**
-     * Put a key/value pair in the JSONObject, but only if the key and the
-     * value are both non-null, and only if there is not already a member
-     * with that name.
-     * @param key
-     * @param value
-     * @return his.
-     * @throws JSONException if the key is a duplicate
-     */
-    public JSONObject putOnce(String key, Object value) throws JSONException {
-        if (key != null && value != null) {
-            if (opt(key) != null) {
-                throw new JSONException("Duplicate key \"" + key + "\"");
-            }
-            put(key, value);
-        }
-        return this;
-    }
-
-
-    /**
-     * Put a key/value pair in the JSONObject, but only if the
-     * key and the value are both non-null.
-     * @param key   A key string.
-     * @param value An object which is the value. It should be of one of these
-     *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
-     *  or the JSONObject.NULL object.
-     * @return this.
-     * @throws JSONException If the value is a non-finite number.
-     */
-    public JSONObject putOpt(String key, Object value) throws JSONException {
-        if (key != null && value != null) {
-            put(key, value);
-        }
-        return this;
-    }
-
-
-    /**
-     * Produce a string in double quotes with backslash sequences in all the
-     * right places. A backslash will be inserted within </, producing <\/,
-     * allowing JSON text to be delivered in HTML. In JSON text, a string 
-     * cannot contain a control character or an unescaped quote or backslash.
-     * @param string A String
-     * @return  A String correctly formatted for insertion in a JSON text.
-     */
-    public static String quote(String string) {
-        if (string == null || string.length() == 0) {
-            return "\"\"";
-        }
-
-        char         b;
-        char         c = 0;
-        String       hhhh;
-        int          i;
-        int          len = string.length();
-        StringBuffer sb = new StringBuffer(len + 4);
-
-        sb.append('"');
-        for (i = 0; i < len; i += 1) {
-            b = c;
-            c = string.charAt(i);
-            switch (c) {
-            case '\\':
-            case '"':
-                sb.append('\\');
-                sb.append(c);
-                break;
-            case '/':
-                if (b == '<') {
-                    sb.append('\\');
-                }
-                sb.append(c);
-                break;
-            case '\b':
-                sb.append("\\b");
-                break;
-            case '\t':
-                sb.append("\\t");
-                break;
-            case '\n':
-                sb.append("\\n");
-                break;
-            case '\f':
-                sb.append("\\f");
-                break;
-            case '\r':
-                sb.append("\\r");
-                break;
-            default:
-                if (c < ' ' || (c >= '\u0080' && c < '\u00a0') ||
-                               (c >= '\u2000' && c < '\u2100')) {
-                    hhhh = "000" + Integer.toHexString(c);
-                    sb.append("\\u" + hhhh.substring(hhhh.length() - 4));
-                } else {
-                    sb.append(c);
-                }
-            }
-        }
-        sb.append('"');
-        return sb.toString();
-    }
-
-    /**
-     * Remove a name and its value, if present.
-     * @param key The name to be removed.
-     * @return The value that was associated with the name,
-     * or null if there was no value.
-     */
-    public Object remove(String key) {
-        return this.map.remove(key);
-    }
-
-    /**
-     * Try to convert a string into a number, boolean, or null. If the string
-     * can't be converted, return the string.
-     * @param string A String.
-     * @return A simple JSON value.
-     */
-    public static Object stringToValue(String string) {
-        if (string.equals("")) {
-            return string;
-        }
-        if (string.equalsIgnoreCase("true")) {
-            return Boolean.TRUE;
-        }
-        if (string.equalsIgnoreCase("false")) {
-            return Boolean.FALSE;
-        }
-        if (string.equalsIgnoreCase("null")) {
-            return JSONObject.NULL;
-        }
-
-        /*
-         * If it might be a number, try converting it. 
-         * We support the non-standard 0x- convention. 
-         * If a number cannot be produced, then the value will just
-         * be a string. Note that the 0x-, plus, and implied string
-         * conventions are non-standard. A JSON parser may accept
-         * non-JSON forms as long as it accepts all correct JSON forms.
-         */
-
-        char b = string.charAt(0);
-        if ((b >= '0' && b <= '9') || b == '.' || b == '-' || b == '+') {
-            if (b == '0' && string.length() > 2 &&
-                        (string.charAt(1) == 'x' || string.charAt(1) == 'X')) {
-                try {
-                    return new Integer(Integer.parseInt(string.substring(2), 16));
-                } catch (Exception ignore) {
-                }
-            }
-            try {
-                if (string.indexOf('.') > -1 || 
-                        string.indexOf('e') > -1 || string.indexOf('E') > -1) {
-                    return Double.valueOf(string);
-                } else {
-                    Long myLong = new Long(string);
-                    if (myLong.longValue() == myLong.intValue()) {
-                        return new Integer(myLong.intValue());
-                    } else {
-                        return myLong;
-                    }
-                }
-            }  catch (Exception ignore) {
-            }
-        }
-        return string;
-    }
-
-
-    /**
-     * Throw an exception if the object is a NaN or infinite number.
-     * @param o The object to test.
-     * @throws JSONException If o is a non-finite number.
-     */
-    public static void testValidity(Object o) throws JSONException {
-        if (o != null) {
-            if (o instanceof Double) {
-                if (((Double)o).isInfinite() || ((Double)o).isNaN()) {
-                    throw new JSONException(
-                        "JSON does not allow non-finite numbers.");
-                }
-            } else if (o instanceof Float) {
-                if (((Float)o).isInfinite() || ((Float)o).isNaN()) {
-                    throw new JSONException(
-                        "JSON does not allow non-finite numbers.");
-                }
-            }
-        }
-    }
-
-
-    /**
-     * Produce a JSONArray containing the values of the members of this
-     * JSONObject.
-     * @param names A JSONArray containing a list of key strings. This
-     * determines the sequence of the values in the result.
-     * @return A JSONArray of values.
-     * @throws JSONException If any of the values are non-finite numbers.
-     */
-    public JSONArray toJSONArray(JSONArray names) throws JSONException {
-        if (names == null || names.length() == 0) {
-            return null;
-        }
-        JSONArray ja = new JSONArray();
-        for (int i = 0; i < names.length(); i += 1) {
-            ja.put(this.opt(names.getString(i)));
-        }
-        return ja;
-    }
-
-    /**
-     * Make a JSON text of this JSONObject. For compactness, no whitespace
-     * is added. If this would not result in a syntactically correct JSON text,
-     * then null will be returned instead.
-     * <p>
-     * Warning: This method assumes that the data structure is acyclical.
-     *
-     * @return a printable, displayable, portable, transmittable
-     *  representation of the object, beginning
-     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
-     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
-     */
-    public String toString() {
-        try {
-            Iterator     keys = this.keys();
-            StringBuffer sb = new StringBuffer("{");
-
-            while (keys.hasNext()) {
-                if (sb.length() > 1) {
-                    sb.append(',');
-                }
-                Object o = keys.next();
-                sb.append(quote(o.toString()));
-                sb.append(':');
-                sb.append(valueToString(this.map.get(o)));
-            }
-            sb.append('}');
-            return sb.toString();
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-
-    /**
-     * Make a prettyprinted JSON text of this JSONObject.
-     * <p>
-     * Warning: This method assumes that the data structure is acyclical.
-     * @param indentFactor The number of spaces to add to each level of
-     *  indentation.
-     * @return a printable, displayable, portable, transmittable
-     *  representation of the object, beginning
-     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
-     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
-     * @throws JSONException If the object contains an invalid number.
-     */
-    public String toString(int indentFactor) throws JSONException {
-        return toString(indentFactor, 0);
-    }
-
-
-    /**
-     * Make a prettyprinted JSON text of this JSONObject.
-     * <p>
-     * Warning: This method assumes that the data structure is acyclical.
-     * @param indentFactor The number of spaces to add to each level of
-     *  indentation.
-     * @param indent The indentation of the top level.
-     * @return a printable, displayable, transmittable
-     *  representation of the object, beginning
-     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
-     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
-     * @throws JSONException If the object contains an invalid number.
-     */
-    String toString(int indentFactor, int indent) throws JSONException {
-        int i;
-        int length = this.length();
-        if (length == 0) {
-            return "{}";
-        }
-        Iterator     keys = this.keys();
-        int          newindent = indent + indentFactor;
-        Object       object;
-        StringBuffer sb = new StringBuffer("{");
-        if (length == 1) {
-            object = keys.next();
-            sb.append(quote(object.toString()));
-            sb.append(": ");
-            sb.append(valueToString(this.map.get(object), indentFactor,
-                    indent));
-        } else {
-            while (keys.hasNext()) {
-                object = keys.next();
-                if (sb.length() > 1) {
-                    sb.append(",\n");
-                } else {
-                    sb.append('\n');
-                }
-                for (i = 0; i < newindent; i += 1) {
-                    sb.append(' ');
-                }
-                sb.append(quote(object.toString()));
-                sb.append(": ");
-                sb.append(valueToString(this.map.get(object), indentFactor,
-                        newindent));
-            }
-            if (sb.length() > 1) {
-                sb.append('\n');
-                for (i = 0; i < indent; i += 1) {
-                    sb.append(' ');
-                }
-            }
-        }
-        sb.append('}');
-        return sb.toString();
-    }
-
-
-    /**
-     * Make a JSON text of an Object value. If the object has an
-     * value.toJSONString() method, then that method will be used to produce
-     * the JSON text. The method is required to produce a strictly
-     * conforming text. If the object does not contain a toJSONString
-     * method (which is the most common case), then a text will be
-     * produced by other means. If the value is an array or Collection,
-     * then a JSONArray will be made from it and its toJSONString method
-     * will be called. If the value is a MAP, then a JSONObject will be made
-     * from it and its toJSONString method will be called. Otherwise, the
-     * value's toString method will be called, and the result will be quoted.
-     *
-     * <p>
-     * Warning: This method assumes that the data structure is acyclical.
-     * @param value The value to be serialized.
-     * @return a printable, displayable, transmittable
-     *  representation of the object, beginning
-     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
-     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
-     * @throws JSONException If the value is or contains an invalid number.
-     */
-    public static String valueToString(Object value) throws JSONException {
-        if (value == null || value.equals(null)) {
-            return "null";
-        }
-        if (value instanceof JSONString) {
-            Object object;
-            try {
-                object = ((JSONString)value).toJSONString();
-            } catch (Exception e) {
-                throw new JSONException(e);
-            }
-            if (object instanceof String) {
-                return (String)object;
-            }
-            throw new JSONException("Bad value from toJSONString: " + object);
-        }
-        if (value instanceof Number) {
-            return numberToString((Number) value);
-        }
-        if (value instanceof Boolean || value instanceof JSONObject ||
-                value instanceof JSONArray) {
-            return value.toString();
-        }
-        if (value instanceof Map) {
-            return new JSONObject((Map)value).toString();
-        }
-        if (value instanceof Collection) {
-            return new JSONArray((Collection)value).toString();
-        }
-        if (value.getClass().isArray()) {
-            return new JSONArray(value).toString();
-        }
-        return quote(value.toString());
-    }
-
-
-    /**
-     * Make a prettyprinted JSON text of an object value.
-     * <p>
-     * Warning: This method assumes that the data structure is acyclical.
-     * @param value The value to be serialized.
-     * @param indentFactor The number of spaces to add to each level of
-     *  indentation.
-     * @param indent The indentation of the top level.
-     * @return a printable, displayable, transmittable
-     *  representation of the object, beginning
-     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
-     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
-     * @throws JSONException If the object contains an invalid number.
-     */
-     static String valueToString(
-         Object value, 
-         int    indentFactor, 
-         int    indent
-     ) throws JSONException {
-        if (value == null || value.equals(null)) {
-            return "null";
-        }
-        try {
-            if (value instanceof JSONString) {
-                Object o = ((JSONString)value).toJSONString();
-                if (o instanceof String) {
-                    return (String)o;
-                }
-            }
-        } catch (Exception ignore) {
-        }
-        if (value instanceof Number) {
-            return numberToString((Number) value);
-        }
-        if (value instanceof Boolean) {
-            return value.toString();
-        }
-        if (value instanceof JSONObject) {
-            return ((JSONObject)value).toString(indentFactor, indent);
-        }
-        if (value instanceof JSONArray) {
-            return ((JSONArray)value).toString(indentFactor, indent);
-        }
-        if (value instanceof Map) {
-            return new JSONObject((Map)value).toString(indentFactor, indent);
-        }
-        if (value instanceof Collection) {
-            return new JSONArray((Collection)value).toString(indentFactor, indent);
-        }
-        if (value.getClass().isArray()) {
-            return new JSONArray(value).toString(indentFactor, indent);
-        }
-        return quote(value.toString());
-    }
-
-
-     /**
-      * Wrap an object, if necessary. If the object is null, return the NULL 
-      * object. If it is an array or collection, wrap it in a JSONArray. If 
-      * it is a map, wrap it in a JSONObject. If it is a standard property 
-      * (Double, String, et al) then it is already wrapped. Otherwise, if it 
-      * comes from one of the java packages, turn it into a string. And if 
-      * it doesn't, try to wrap it in a JSONObject. If the wrapping fails,
-      * then null is returned.
-      *
-      * @param object The object to wrap
-      * @return The wrapped value
-      */
-     public static Object wrap(Object object) {
-         try {
-             if (object == null) {
-                 return NULL;
-             }
-             if (object instanceof JSONObject || object instanceof JSONArray  || 
-                     NULL.equals(object)      || object instanceof JSONString || 
-                     object instanceof Byte   || object instanceof Character  ||
-                     object instanceof Short  || object instanceof Integer    ||
-                     object instanceof Long   || object instanceof Boolean    || 
-                     object instanceof Float  || object instanceof Double     ||
-                     object instanceof String) {
-                 return object;
-             }
-             
-             if (object instanceof Collection) {
-                 return new JSONArray((Collection)object);
-             }
-             if (object.getClass().isArray()) {
-                 return new JSONArray(object);
-             }
-             if (object instanceof Map) {
-                 return new JSONObject((Map)object);
-             }
-             Package objectPackage = object.getClass().getPackage();
-             String objectPackageName = objectPackage != null ? 
-                 objectPackage.getName() : "";
-             if (
-                 objectPackageName.startsWith("java.") ||
-                 objectPackageName.startsWith("javax.") ||
-                 object.getClass().getClassLoader() == null
-             ) {
-                 return object.toString();
-             }
-             return new JSONObject(object);
-         } catch(Exception exception) {
-             return null;
-         }
-     }
-
-     
-     /**
-      * Write the contents of the JSONObject as JSON text to a writer.
-      * For compactness, no whitespace is added.
-      * <p>
-      * Warning: This method assumes that the data structure is acyclical.
-      *
-      * @return The writer.
-      * @throws JSONException
-      */
-     public Writer write(Writer writer) throws JSONException {
-        try {
-            boolean  commanate = false;
-            Iterator keys = this.keys();
-            writer.write('{');
-
-            while (keys.hasNext()) {
-                if (commanate) {
-                    writer.write(',');
-                }
-                Object key = keys.next();
-                writer.write(quote(key.toString()));
-                writer.write(':');
-                Object value = this.map.get(key);
-                if (value instanceof JSONObject) {
-                    ((JSONObject)value).write(writer);
-                } else if (value instanceof JSONArray) {
-                    ((JSONArray)value).write(writer);
-                } else {
-                    writer.write(valueToString(value));
-                }
-                commanate = true;
-            }
-            writer.write('}');
-            return writer;
-        } catch (IOException exception) {
-            throw new JSONException(exception);
-        }
-     }
-}
\ No newline at end of file
Index: out/production/OOP_EX2/java-json.jar/org/json/HTTPTokener.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/HTTPTokener.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/HTTPTokener.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,77 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-/**
- * The HTTPTokener extends the JSONTokener to provide additional methods
- * for the parsing of HTTP headers.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class HTTPTokener extends JSONTokener {
-
-    /**
-     * Construct an HTTPTokener from a string.
-     * @param string A source string.
-     */
-    public HTTPTokener(String string) {
-        super(string);
-    }
-
-
-    /**
-     * Get the next token or string. This is used in parsing HTTP headers.
-     * @throws JSONException
-     * @return A String.
-     */
-    public String nextToken() throws JSONException {
-        char c;
-        char q;
-        StringBuffer sb = new StringBuffer();
-        do {
-            c = next();
-        } while (Character.isWhitespace(c));
-        if (c == '"' || c == '\'') {
-            q = c;
-            for (;;) {
-                c = next();
-                if (c < ' ') {
-                    throw syntaxError("Unterminated string.");
-                }
-                if (c == q) {
-                    return sb.toString();
-                }
-                sb.append(c);
-            }
-        } 
-        for (;;) {
-            if (c == 0 || Character.isWhitespace(c)) {
-                return sb.toString();
-            }
-            sb.append(c);
-            c = next();
-        }
-    }
-}
Index: out/production/OOP_EX2/java-json.jar/org/json/XMLTokener.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/XMLTokener.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/XMLTokener.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,365 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-/**
- * The XMLTokener extends the JSONTokener to provide additional methods
- * for the parsing of XML texts.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class XMLTokener extends JSONTokener {
-
-
-   /** The table of entity values. It initially contains Character values for
-    * amp, apos, gt, lt, quot.
-    */
-   public static final java.util.HashMap entity;
-
-   static {
-       entity = new java.util.HashMap(8);
-       entity.put("amp",  XML.AMP);
-       entity.put("apos", XML.APOS);
-       entity.put("gt",   XML.GT);
-       entity.put("lt",   XML.LT);
-       entity.put("quot", XML.QUOT);
-   }
-
-    /**
-     * Construct an XMLTokener from a string.
-     * @param s A source string.
-     */
-    public XMLTokener(String s) {
-        super(s);
-    }
-
-    /**
-     * Get the text in the CDATA block.
-     * @return The string up to the <code>]]&gt;</code>.
-     * @throws JSONException If the <code>]]&gt;</code> is not found.
-     */
-    public String nextCDATA() throws JSONException {
-        char         c;
-        int          i;
-        StringBuffer sb = new StringBuffer();
-        for (;;) {
-            c = next();
-            if (end()) {
-                throw syntaxError("Unclosed CDATA");
-            }
-            sb.append(c);
-            i = sb.length() - 3;
-            if (i >= 0 && sb.charAt(i) == ']' &&
-                          sb.charAt(i + 1) == ']' && sb.charAt(i + 2) == '>') {
-                sb.setLength(i);
-                return sb.toString();
-            }
-        }
-    }
-
-
-    /**
-     * Get the next XML outer token, trimming whitespace. There are two kinds
-     * of tokens: the '<' character which begins a markup tag, and the content
-     * text between markup tags.
-     *
-     * @return  A string, or a '<' Character, or null if there is no more
-     * source text.
-     * @throws JSONException
-     */
-    public Object nextContent() throws JSONException {
-        char         c;
-        StringBuffer sb;
-        do {
-            c = next();
-        } while (Character.isWhitespace(c));
-        if (c == 0) {
-            return null;
-        }
-        if (c == '<') {
-            return XML.LT;
-        }
-        sb = new StringBuffer();
-        for (;;) {
-            if (c == '<' || c == 0) {
-                back();
-                return sb.toString().trim();
-            }
-            if (c == '&') {
-                sb.append(nextEntity(c));
-            } else {
-                sb.append(c);
-            }
-            c = next();
-        }
-    }
-
-
-    /**
-     * Return the next entity. These entities are translated to Characters:
-     *     <code>&amp;  &apos;  &gt;  &lt;  &quot;</code>.
-     * @param ampersand An ampersand character.
-     * @return  A Character or an entity String if the entity is not recognized.
-     * @throws JSONException If missing ';' in XML entity.
-     */
-    public Object nextEntity(char ampersand) throws JSONException {
-        StringBuffer sb = new StringBuffer();
-        for (;;) {
-            char c = next();
-            if (Character.isLetterOrDigit(c) || c == '#') {
-                sb.append(Character.toLowerCase(c));
-            } else if (c == ';') {
-                break;
-            } else {
-                throw syntaxError("Missing ';' in XML entity: &" + sb);
-            }
-        }
-        String string = sb.toString();
-        Object object = entity.get(string);
-        return object != null ? object : ampersand + string + ";";
-    }
-
-
-    /**
-     * Returns the next XML meta token. This is used for skipping over <!...>
-     * and <?...?> structures.
-     * @return Syntax characters (<code>< > / = ! ?</code>) are returned as
-     *  Character, and strings and names are returned as Boolean. We don't care
-     *  what the values actually are.
-     * @throws JSONException If a string is not properly closed or if the XML
-     *  is badly structured.
-     */
-    public Object nextMeta() throws JSONException {
-        char c;
-        char q;
-        do {
-            c = next();
-        } while (Character.isWhitespace(c));
-        switch (c) {
-        case 0:
-            throw syntaxError("Misshaped meta tag");
-        case '<':
-            return XML.LT;
-        case '>':
-            return XML.GT;
-        case '/':
-            return XML.SLASH;
-        case '=':
-            return XML.EQ;
-        case '!':
-            return XML.BANG;
-        case '?':
-            return XML.QUEST;
-        case '"':
-        case '\'':
-            q = c;
-            for (;;) {
-                c = next();
-                if (c == 0) {
-                    throw syntaxError("Unterminated string");
-                }
-                if (c == q) {
-                    return Boolean.TRUE;
-                }
-            }
-        default:
-            for (;;) {
-                c = next();
-                if (Character.isWhitespace(c)) {
-                    return Boolean.TRUE;
-                }
-                switch (c) {
-                case 0:
-                case '<':
-                case '>':
-                case '/':
-                case '=':
-                case '!':
-                case '?':
-                case '"':
-                case '\'':
-                    back();
-                    return Boolean.TRUE;
-                }
-            }
-        }
-    }
-
-
-    /**
-     * Get the next XML Token. These tokens are found inside of angle
-     * brackets. It may be one of these characters: <code>/ > = ! ?</code> or it
-     * may be a string wrapped in single quotes or double quotes, or it may be a
-     * name.
-     * @return a String or a Character.
-     * @throws JSONException If the XML is not well formed.
-     */
-    public Object nextToken() throws JSONException {
-        char c;
-        char q;
-        StringBuffer sb;
-        do {
-            c = next();
-        } while (Character.isWhitespace(c));
-        switch (c) {
-        case 0:
-            throw syntaxError("Misshaped element");
-        case '<':
-            throw syntaxError("Misplaced '<'");
-        case '>':
-            return XML.GT;
-        case '/':
-            return XML.SLASH;
-        case '=':
-            return XML.EQ;
-        case '!':
-            return XML.BANG;
-        case '?':
-            return XML.QUEST;
-
-// Quoted string
-
-        case '"':
-        case '\'':
-            q = c;
-            sb = new StringBuffer();
-            for (;;) {
-                c = next();
-                if (c == 0) {
-                    throw syntaxError("Unterminated string");
-                }
-                if (c == q) {
-                    return sb.toString();
-                }
-                if (c == '&') {
-                    sb.append(nextEntity(c));
-                } else {
-                    sb.append(c);
-                }
-            }
-        default:
-
-// Name
-
-            sb = new StringBuffer();
-            for (;;) {
-                sb.append(c);
-                c = next();
-                if (Character.isWhitespace(c)) {
-                    return sb.toString();
-                }
-                switch (c) {
-                case 0:
-                	return sb.toString();
-                case '>':
-                case '/':
-                case '=':
-                case '!':
-                case '?':
-                case '[':
-                case ']':
-                    back();
-                    return sb.toString();
-                case '<':
-                case '"':
-                case '\'':
-                    throw syntaxError("Bad character in a name");
-                }
-            }
-        }
-    }
-    
-    
-    /**
-     * Skip characters until past the requested string.
-     * If it is not found, we are left at the end of the source with a result of false.
-     * @param to A string to skip past.
-     * @throws JSONException
-     */
-    public boolean skipPast(String to) throws JSONException {
-    	boolean b;
-    	char c;
-    	int i;
-    	int j;
-    	int offset = 0;
-    	int length = to.length();
-        char[] circle = new char[length];
-        
-        /*
-         * First fill the circle buffer with as many characters as are in the
-         * to string. If we reach an early end, bail.
-         */
-        
-    	for (i = 0; i < length; i += 1) {
-    		c = next();
-    		if (c == 0) {
-    			return false;
-    		}
-    		circle[i] = c;
-    	}
-    	/*
-    	 * We will loop, possibly for all of the remaining characters.
-    	 */
-    	for (;;) {
-    		j = offset;
-    		b = true;
-    		/*
-    		 * Compare the circle buffer with the to string. 
-    		 */
-    		for (i = 0; i < length; i += 1) {
-    			if (circle[j] != to.charAt(i)) {
-    				b = false;
-    				break;
-    			}
-    			j += 1;
-    			if (j >= length) {
-    				j -= length;
-    			}
-    		}
-    		/*
-    		 * If we exit the loop with b intact, then victory is ours.
-    		 */
-    		if (b) {
-    			return true;
-    		}
-    		/*
-    		 * Get the next character. If there isn't one, then defeat is ours.
-    		 */
-    		c = next();
-    		if (c == 0) {
-    			return false;
-    		}
-    		/*
-    		 * Shove the character in the circle buffer and advance the 
-    		 * circle offset. The offset is mod n.
-    		 */
-    		circle[offset] = c;
-    		offset += 1;
-    		if (offset >= length) {
-    			offset -= length;
-    		}
-    	}
-    }
-}
Index: out/production/OOP_EX2/java-json.jar/org/json/CDL.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/CDL.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/CDL.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,279 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-/**
- * This provides static methods to convert comma delimited text into a
- * JSONArray, and to covert a JSONArray into comma delimited text. Comma
- * delimited text is a very popular format for data interchange. It is
- * understood by most database, spreadsheet, and organizer programs.
- * <p>
- * Each row of text represents a row in a table or a data record. Each row
- * ends with a NEWLINE character. Each row contains one or more values.
- * Values are separated by commas. A value can contain any character except
- * for comma, unless is is wrapped in single quotes or double quotes.
- * <p>
- * The first row usually contains the names of the columns.
- * <p>
- * A comma delimited list can be converted into a JSONArray of JSONObjects.
- * The names for the elements in the JSONObjects can be taken from the names
- * in the first row.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class CDL {
-
-    /**
-     * Get the next value. The value can be wrapped in quotes. The value can
-     * be empty.
-     * @param x A JSONTokener of the source text.
-     * @return The value string, or null if empty.
-     * @throws JSONException if the quoted string is badly formed.
-     */
-    private static String getValue(JSONTokener x) throws JSONException {
-        char c;
-        char q;
-        StringBuffer sb;
-        do {
-            c = x.next();
-        } while (c == ' ' || c == '\t');
-        switch (c) {
-        case 0:
-            return null;
-        case '"':
-        case '\'':
-        	q = c;
-        	sb = new StringBuffer();
-        	for (;;) {
-        		c = x.next();
-        		if (c == q) {
-        			break;
-        		}
-                if (c == 0 || c == '\n' || c == '\r') {
-                    throw x.syntaxError("Missing close quote '" + q + "'.");
-                }
-                sb.append(c);
-        	}
-            return sb.toString();
-        case ',':
-            x.back();
-            return "";
-        default:
-            x.back();
-            return x.nextTo(',');
-        }
-    }
-
-    /**
-     * Produce a JSONArray of strings from a row of comma delimited values.
-     * @param x A JSONTokener of the source text.
-     * @return A JSONArray of strings.
-     * @throws JSONException
-     */
-    public static JSONArray rowToJSONArray(JSONTokener x) throws JSONException {
-        JSONArray ja = new JSONArray();
-        for (;;) {
-            String value = getValue(x);
-            char c = x.next();
-            if (value == null || 
-            		(ja.length() == 0 && value.length() == 0 && c != ',')) {
-                return null;
-            }
-            ja.put(value);
-            for (;;) {                
-                if (c == ',') {
-                    break;
-                }
-                if (c != ' ') {
-                    if (c == '\n' || c == '\r' || c == 0) {
-                        return ja;
-                    }
-                    throw x.syntaxError("Bad character '" + c + "' (" +
-                            (int)c + ").");
-                }
-                c = x.next();
-            }
-        }
-    }
-
-    /**
-     * Produce a JSONObject from a row of comma delimited text, using a
-     * parallel JSONArray of strings to provides the names of the elements.
-     * @param names A JSONArray of names. This is commonly obtained from the
-     *  first row of a comma delimited text file using the rowToJSONArray
-     *  method.
-     * @param x A JSONTokener of the source text.
-     * @return A JSONObject combining the names and values.
-     * @throws JSONException
-     */
-    public static JSONObject rowToJSONObject(JSONArray names, JSONTokener x)
-            throws JSONException {
-        JSONArray ja = rowToJSONArray(x);
-        return ja != null ? ja.toJSONObject(names) :  null;
-    }
-
-    /**
-	 * Produce a comma delimited text row from a JSONArray. Values containing
-	 * the comma character will be quoted. Troublesome characters may be 
-	 * removed.
-	 * @param ja A JSONArray of strings.
-	 * @return A string ending in NEWLINE.
-	 */
-	public static String rowToString(JSONArray ja) {
-	    StringBuffer sb = new StringBuffer();
-	    for (int i = 0; i < ja.length(); i += 1) {
-	        if (i > 0) {
-	            sb.append(',');
-	        }
-	        Object object = ja.opt(i);
-	        if (object != null) {
-	            String string = object.toString();
-	            if (string.length() > 0 && (string.indexOf(',') >= 0 || 
-	            		string.indexOf('\n') >= 0 || string.indexOf('\r') >= 0 || 
-	            		string.indexOf(0) >= 0 || string.charAt(0) == '"')) {
-	                sb.append('"');
-	            	int length = string.length();
-	            	for (int j = 0; j < length; j += 1) {
-	            		char c = string.charAt(j);
-	            		if (c >= ' ' && c != '"') {
-	            			sb.append(c);
-	            		}
-	                }
-	                sb.append('"');
-	            } else {
-	                sb.append(string);
-	            }
-	        }
-	    }
-	    sb.append('\n');
-	    return sb.toString();
-	}
-
-	/**
-     * Produce a JSONArray of JSONObjects from a comma delimited text string,
-     * using the first row as a source of names.
-     * @param string The comma delimited text.
-     * @return A JSONArray of JSONObjects.
-     * @throws JSONException
-     */
-    public static JSONArray toJSONArray(String string) throws JSONException {
-        return toJSONArray(new JSONTokener(string));
-    }
-
-    /**
-     * Produce a JSONArray of JSONObjects from a comma delimited text string,
-     * using the first row as a source of names.
-     * @param x The JSONTokener containing the comma delimited text.
-     * @return A JSONArray of JSONObjects.
-     * @throws JSONException
-     */
-    public static JSONArray toJSONArray(JSONTokener x) throws JSONException {
-        return toJSONArray(rowToJSONArray(x), x);
-    }
-
-    /**
-     * Produce a JSONArray of JSONObjects from a comma delimited text string
-     * using a supplied JSONArray as the source of element names.
-     * @param names A JSONArray of strings.
-     * @param string The comma delimited text.
-     * @return A JSONArray of JSONObjects.
-     * @throws JSONException
-     */
-    public static JSONArray toJSONArray(JSONArray names, String string)
-            throws JSONException {
-        return toJSONArray(names, new JSONTokener(string));
-    }
-
-    /**
-     * Produce a JSONArray of JSONObjects from a comma delimited text string
-     * using a supplied JSONArray as the source of element names.
-     * @param names A JSONArray of strings.
-     * @param x A JSONTokener of the source text.
-     * @return A JSONArray of JSONObjects.
-     * @throws JSONException
-     */
-    public static JSONArray toJSONArray(JSONArray names, JSONTokener x)
-            throws JSONException {
-        if (names == null || names.length() == 0) {
-            return null;
-        }
-        JSONArray ja = new JSONArray();
-        for (;;) {
-            JSONObject jo = rowToJSONObject(names, x);
-            if (jo == null) {
-                break;
-            }
-            ja.put(jo);
-        }
-        if (ja.length() == 0) {
-            return null;
-        }
-        return ja;
-    }
-
-
-    /**
-     * Produce a comma delimited text from a JSONArray of JSONObjects. The
-     * first row will be a list of names obtained by inspecting the first
-     * JSONObject.
-     * @param ja A JSONArray of JSONObjects.
-     * @return A comma delimited text.
-     * @throws JSONException
-     */
-    public static String toString(JSONArray ja) throws JSONException {
-        JSONObject jo = ja.optJSONObject(0);
-        if (jo != null) {
-            JSONArray names = jo.names();
-            if (names != null) {
-                return rowToString(names) + toString(names, ja);
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Produce a comma delimited text from a JSONArray of JSONObjects using
-     * a provided list of names. The list of names is not included in the
-     * output.
-     * @param names A JSONArray of strings.
-     * @param ja A JSONArray of JSONObjects.
-     * @return A comma delimited text.
-     * @throws JSONException
-     */
-    public static String toString(JSONArray names, JSONArray ja)
-            throws JSONException {
-        if (names == null || names.length() == 0) {
-            return null;
-        }
-        StringBuffer sb = new StringBuffer();
-        for (int i = 0; i < ja.length(); i += 1) {
-            JSONObject jo = ja.optJSONObject(i);
-            if (jo != null) {
-                sb.append(rowToString(jo.toJSONArray(names)));
-            }
-        }
-        return sb.toString();
-    }
-}
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONML.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONML.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONML.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,456 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2008 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-import java.util.Iterator;
-
-
-/**
- * This provides static methods to convert an XML text into a JSONArray or 
- * JSONObject, and to covert a JSONArray or JSONObject into an XML text using 
- * the JsonML transform.
- * @author JSON.org
- * @version 2010-12-23
- */
-public class JSONML {
-		
-    /**
-     * Parse XML values and store them in a JSONArray.
-     * @param x       The XMLTokener containing the source string.
-     * @param arrayForm true if array form, false if object form.
-     * @param ja      The JSONArray that is containing the current tag or null
-     *     if we are at the outermost level.
-     * @return A JSONArray if the value is the outermost tag, otherwise null.
-     * @throws JSONException
-     */
-    private static Object parse(XMLTokener x, boolean arrayForm, 
-    		JSONArray ja) throws JSONException {
-        String     attribute;
-        char       c;
-        String	   closeTag = null;
-        int        i;
-        JSONArray  newja = null;
-        JSONObject newjo = null;
-        Object     token;
-        String	   tagName = null;
-        
-// Test for and skip past these forms:
-//      <!-- ... -->
-//      <![  ... ]]>
-//      <!   ...   >
-//      <?   ...  ?>
-        
-        while (true) {
-        	token = x.nextContent();
-    		if (token == XML.LT) {
-    			token = x.nextToken();
-    			if (token instanceof Character) {
-			        if (token == XML.SLASH) {
-
-// Close tag </
-
-			        	token = x.nextToken();
-			        	if (!(token instanceof String)) {
-			        		throw new JSONException(
-			        				"Expected a closing name instead of '" + 
-			        				token + "'.");
-			        	}
-			            if (x.nextToken() != XML.GT) {
-			                throw x.syntaxError("Misshaped close tag");
-			            }
-			            return token;
-			        } else if (token == XML.BANG) {
-        		
-// <!
-        	
-			            c = x.next();
-			            if (c == '-') {
-			                if (x.next() == '-') {
-			                    x.skipPast("-->");
-			                }
-			                x.back();
-			            } else if (c == '[') {
-			                token = x.nextToken();
-			                if (token.equals("CDATA") && x.next() == '[') {
-			                	if (ja != null) {
-			                		ja.put(x.nextCDATA());
-			                	}
-			                } else {
-			                	throw x.syntaxError("Expected 'CDATA['");
-			                }
-			            } else {
-				            i = 1;
-				            do {
-				                token = x.nextMeta();
-				                if (token == null) {
-				                    throw x.syntaxError("Missing '>' after '<!'.");
-				                } else if (token == XML.LT) {
-				                    i += 1;
-				                } else if (token == XML.GT) {
-				                    i -= 1;
-				                }
-				            } while (i > 0);
-			            }
-			        } else if (token == XML.QUEST) {
-
-// <?
-
-			        	x.skipPast("?>");
-			        } else {
-			            throw x.syntaxError("Misshaped tag");
-			        }
-
-// Open tag <
-
-		        } else {
-		        	if (!(token instanceof String)) {
-			            throw x.syntaxError("Bad tagName '" + token + "'.");		        		
-		        	}
-		        	tagName = (String)token;
-		            newja = new JSONArray();		
-		            newjo = new JSONObject();
-		        	if (arrayForm) {
-			            newja.put(tagName);
-			            if (ja != null) {
-			            	ja.put(newja);
-			            }
-			        } else {
-		        		newjo.put("tagName", tagName);
-		        		if (ja != null) {
-			            	ja.put(newjo);
-			            }
-			        }
-		            token = null;
-		            for (;;) {
-		                if (token == null) {
-		                    token = x.nextToken();
-		                }
-		                if (token == null) {
-		                	throw x.syntaxError("Misshaped tag");
-		                }
-		                if (!(token instanceof String)) {
-		                	break;
-		                }
-
-// attribute = value
-
-	                    attribute = (String)token;
-			        	if (!arrayForm && (attribute == "tagName" || attribute == "childNode")) {
-                            throw x.syntaxError("Reserved attribute.");			        		
-			        	}
-	                    token = x.nextToken();
-	                    if (token == XML.EQ) {
-	                        token = x.nextToken();
-	                        if (!(token instanceof String)) {
-	                            throw x.syntaxError("Missing value");
-	                        }
-	                        newjo.accumulate(attribute, XML.stringToValue((String)token));
-	                        token = null;
-	                    } else {
-	                    	newjo.accumulate(attribute, "");
-	                    }
-		            }
-                    if (arrayForm && newjo.length() > 0) {
-                    	newja.put(newjo);
-                    }
-
-// Empty tag <.../>
-
-	                if (token == XML.SLASH) {
-	                    if (x.nextToken() != XML.GT) {
-	                        throw x.syntaxError("Misshaped tag");
-	                    }
-	                    if (ja == null) {
-	                    	if (arrayForm) {
-	                    		return newja;
-	                    	} else {
-	                    		return newjo;
-	                    	}
-	                    }
-
-// Content, between <...> and </...>
-
-	                } else {
-	                	if (token != XML.GT) {
-	                		throw x.syntaxError("Misshaped tag");
-	                	}
-	                	closeTag = (String)parse(x, arrayForm, newja);
-	                	if (closeTag != null) {
-		                	if (!closeTag.equals(tagName)) {
-		                		throw x.syntaxError("Mismatched '" + tagName + 
-		                				"' and '" + closeTag + "'");
-					        }
-		                	tagName = null;
-		            		if (!arrayForm && newja.length() > 0) {
-		            			newjo.put("childNodes", newja);
-		            		}
-		                	if (ja == null) {
-		                    	if (arrayForm) {
-		                    		return newja;
-		                    	} else {
-		                    		return newjo;
-		                    	}
-		                	}
-	                	}
-                	}
-	            }
-		    } else {
-		    	if (ja != null) {
-		    		ja.put(token instanceof String ? 
-		    				XML.stringToValue((String)token) : token);
-		    	}
-		    }
-        }
-    }
-
-
-    /**
-     * Convert a well-formed (but not necessarily valid) XML string into a
-     * JSONArray using the JsonML transform. Each XML tag is represented as
-     * a JSONArray in which the first element is the tag name. If the tag has
-     * attributes, then the second element will be JSONObject containing the
-     * name/value pairs. If the tag contains children, then strings and
-     * JSONArrays will represent the child tags.
-     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
-     * @param string The source string.
-     * @return A JSONArray containing the structured data from the XML string.
-     * @throws JSONException
-     */
-    public static JSONArray toJSONArray(String string) throws JSONException {
-    	return toJSONArray(new XMLTokener(string));
-    }
-
-
-    /**
-     * Convert a well-formed (but not necessarily valid) XML string into a
-     * JSONArray using the JsonML transform. Each XML tag is represented as
-     * a JSONArray in which the first element is the tag name. If the tag has
-     * attributes, then the second element will be JSONObject containing the
-     * name/value pairs. If the tag contains children, then strings and
-     * JSONArrays will represent the child content and tags.
-     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
-     * @param x An XMLTokener.
-     * @return A JSONArray containing the structured data from the XML string.
-     * @throws JSONException
-     */
-    public static JSONArray toJSONArray(XMLTokener x) throws JSONException {
-    	return (JSONArray)parse(x, true, null);
-    }
-
-    
-    /**
-     * Convert a well-formed (but not necessarily valid) XML string into a
-     * JSONObject using the JsonML transform. Each XML tag is represented as
-     * a JSONObject with a "tagName" property. If the tag has attributes, then 
-     * the attributes will be in the JSONObject as properties. If the tag 
-     * contains children, the object will have a "childNodes" property which 
-     * will be an array of strings and JsonML JSONObjects.
-
-     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
-     * @param x An XMLTokener of the XML source text.
-     * @return A JSONObject containing the structured data from the XML string.
-     * @throws JSONException
-     */
-    public static JSONObject toJSONObject(XMLTokener x) throws JSONException {
-       	return (JSONObject)parse(x, false, null);
-    }
-    
-    
-    /**
-     * Convert a well-formed (but not necessarily valid) XML string into a
-     * JSONObject using the JsonML transform. Each XML tag is represented as
-     * a JSONObject with a "tagName" property. If the tag has attributes, then 
-     * the attributes will be in the JSONObject as properties. If the tag 
-     * contains children, the object will have a "childNodes" property which 
-     * will be an array of strings and JsonML JSONObjects.
-
-     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
-     * @param string The XML source text.
-     * @return A JSONObject containing the structured data from the XML string.
-     * @throws JSONException
-     */
-    public static JSONObject toJSONObject(String string) throws JSONException {
-    	return toJSONObject(new XMLTokener(string));
-    }
-
-
-    /**
-     * Reverse the JSONML transformation, making an XML text from a JSONArray.
-     * @param ja A JSONArray.
-     * @return An XML string.
-     * @throws JSONException
-     */
-    public static String toString(JSONArray ja) throws JSONException {
-    	int			 i;
-    	JSONObject   jo;
-    	String       key;
-	    Iterator     keys;
-	    int			 length;
-    	Object		 object;
-    	StringBuffer sb = new StringBuffer();
-	    String       tagName;
-	    String       value;
-	    
-// Emit <tagName	    
-    	
-    	tagName = ja.getString(0);
-		XML.noSpace(tagName);
-		tagName = XML.escape(tagName);
-		sb.append('<');
-		sb.append(tagName);
-		
-		object = ja.opt(1);
-		if (object instanceof JSONObject) {
-			i = 2;
-			jo = (JSONObject)object;
-			
-// Emit the attributes
-			
-	        keys = jo.keys();
-	        while (keys.hasNext()) {
-	            key = keys.next().toString();
-            	XML.noSpace(key);
-	            value = jo.optString(key);
-	            if (value != null) {
-		            sb.append(' ');
-		            sb.append(XML.escape(key));
-		            sb.append('=');
-		            sb.append('"');
-		            sb.append(XML.escape(value));
-		            sb.append('"');
-	            }
-	        }  
-		} else {
-			i = 1;
-		}
-	     	
-//Emit content in body
-	    	
-		length = ja.length();
-		if (i >= length) {
-	        sb.append('/');
-	        sb.append('>');
-		} else {
-	        sb.append('>');
-			do {
-			    object = ja.get(i);
-			    i += 1;
-			    if (object != null) {
-			    	if (object instanceof String) {
-			    		sb.append(XML.escape(object.toString()));
-					} else if (object instanceof JSONObject) {
-						sb.append(toString((JSONObject)object));
-					} else if (object instanceof JSONArray) {
-						sb.append(toString((JSONArray)object));
-					}
-			    }
-			} while (i < length);
-			sb.append('<');
-	        sb.append('/');
-			sb.append(tagName);
-	        sb.append('>');
-	    }
-        return sb.toString();
-    }
-    
-    /**
-     * Reverse the JSONML transformation, making an XML text from a JSONObject.
-     * The JSONObject must contain a "tagName" property. If it has children, 
-     * then it must have a "childNodes" property containing an array of objects. 
-     * The other properties are attributes with string values.
-     * @param jo A JSONObject.
-     * @return An XML string.
-     * @throws JSONException
-     */
-	public static String toString(JSONObject jo) throws JSONException {
-	    StringBuffer sb = new StringBuffer();
-	    int          i;
-	    JSONArray    ja;
-	    String       key;
-	    Iterator     keys;
-	    int          length;
-	    Object		 object;
-	    String       tagName;
-	    String       value;
-	
-//Emit <tagName
-	
-		tagName = jo.optString("tagName");
-		if (tagName == null) {
-			return XML.escape(jo.toString());
-		}
-		XML.noSpace(tagName);
-		tagName = XML.escape(tagName);
-		sb.append('<');
-		sb.append(tagName);
-	
-//Emit the attributes
-	
-        keys = jo.keys();
-        while (keys.hasNext()) {
-            key = keys.next().toString();
-            if (!key.equals("tagName") && !key.equals("childNodes")) {
-            	XML.noSpace(key);
-	            value = jo.optString(key);
-	            if (value != null) {
-		            sb.append(' ');
-		            sb.append(XML.escape(key));
-		            sb.append('=');
-		            sb.append('"');
-		            sb.append(XML.escape(value));
-		            sb.append('"');
-	            }
-            }
-        }    
-		     	
-//Emit content in body
-	
-		ja = jo.optJSONArray("childNodes");
-		if (ja == null) {
-	        sb.append('/');
-	        sb.append('>');
-		} else {
-	        sb.append('>');
-			length = ja.length();
-			for (i = 0; i < length; i += 1) {
-			    object = ja.get(i);
-			    if (object != null) {
-			    	if (object instanceof String) {
-			    		sb.append(XML.escape(object.toString()));
-					} else if (object instanceof JSONObject) {
-						sb.append(toString((JSONObject)object));
-					} else if (object instanceof JSONArray) {
-						sb.append(toString((JSONArray)object));
-					}
-			    }
-			}
-			sb.append('<');
-	        sb.append('/');
-			sb.append(tagName);
-	        sb.append('>');
-	    }
-        return sb.toString();
-    }
-}
\ No newline at end of file
Index: out/production/OOP_EX2/Ex2_Server_v0.13.jar/META-INF/MANIFEST.MF
===================================================================
--- out/production/OOP_EX2/Ex2_Server_v0.13.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/Ex2_Server_v0.13.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,3 +0,0 @@
-Manifest-Version: 1.0
-Sealed: true
-
Index: src/gameClient/files/GUI.java
===================================================================
--- src/gameClient/files/GUI.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ src/gameClient/files/GUI.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,32 +0,0 @@
-package gameClient.files;
-
-import javax.swing.*;
-import java.awt.*;
-
-public class GUI extends JFrame{
-    private static JTextField UseNameText;
-    private static JLabel User_Name_Label;
-    private static JLabel scenario_Label;
-    private static JTextField scenarioText;
-    private static JPanel panel;
-    private static JButton button;
-    private static int UserName;
-    public static int scenario;
-
-    public static JFrame frame;
-    private static Image image;
-    private static Graphics g;
-    private int[] ans;
-
-    public static void main(String[] args) {
-        GUI gg=new GUI();
-        gg.setVisible(true);
-    }
-    public GUI() {
-       setSize(1000,700);
-    }
-    public void init() throws InterruptedException {
-
-    }
-
-        }
Index: .idea/.gitignore
===================================================================
--- .idea/.gitignore	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ .idea/.gitignore	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,6 +0,0 @@
-# Default ignored files
-/shelf/
-*.xml
-*.iml
-/out/*
-/.idea/*
\ No newline at end of file
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONException.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONException.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONException.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,28 +0,0 @@
-package org.json;
-
-/**
- * The JSONException is thrown by the JSON.org classes when things are amiss.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class JSONException extends Exception {
-	private static final long serialVersionUID = 0;
-	private Throwable cause;
-
-    /**
-     * Constructs a JSONException with an explanatory message.
-     * @param message Detail about the reason for the exception.
-     */
-    public JSONException(String message) {
-        super(message);
-    }
-
-    public JSONException(Throwable cause) {
-        super(cause.getMessage());
-        this.cause = cause;
-    }
-
-    public Throwable getCause() {
-        return this.cause;
-    }
-}
Index: out/production/OOP_EX2/okhttp-4.8.0.jar/META-INF/proguard/okhttp3.pro
===================================================================
--- out/production/OOP_EX2/okhttp-4.8.0.jar/META-INF/proguard/okhttp3.pro	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/okhttp-4.8.0.jar/META-INF/proguard/okhttp3.pro	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,11 +0,0 @@
-# JSR 305 annotations are for embedding nullability information.
--dontwarn javax.annotation.**
-
-# A resource is loaded with a relative path so the package of this class must be preserved.
--keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
-
-# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
--dontwarn org.codehaus.mojo.animal_sniffer.*
-
-# OkHttp platform used only on JVM and when Conscrypt dependency is available.
--dontwarn okhttp3.internal.platform.ConscryptPlatform
Index: out/production/OOP_EX2/java-json.jar/org/json/CookieList.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/CookieList.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/CookieList.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,90 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-import java.util.Iterator;
-
-/**
- * Convert a web browser cookie list string to a JSONObject and back.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class CookieList {
-
-    /**
-     * Convert a cookie list into a JSONObject. A cookie list is a sequence
-     * of name/value pairs. The names are separated from the values by '='.
-     * The pairs are separated by ';'. The names and the values
-     * will be unescaped, possibly converting '+' and '%' sequences.
-     *
-     * To add a cookie to a cooklist,
-     * cookielistJSONObject.put(cookieJSONObject.getString("name"),
-     *     cookieJSONObject.getString("value"));
-     * @param string  A cookie list string
-     * @return A JSONObject
-     * @throws JSONException
-     */
-    public static JSONObject toJSONObject(String string) throws JSONException {
-        JSONObject jo = new JSONObject();
-        JSONTokener x = new JSONTokener(string);
-        while (x.more()) {
-            String name = Cookie.unescape(x.nextTo('='));
-            x.next('=');
-            jo.put(name, Cookie.unescape(x.nextTo(';')));
-            x.next();
-        }
-        return jo;
-    }
-
-
-    /**
-     * Convert a JSONObject into a cookie list. A cookie list is a sequence
-     * of name/value pairs. The names are separated from the values by '='.
-     * The pairs are separated by ';'. The characters '%', '+', '=', and ';'
-     * in the names and values are replaced by "%hh".
-     * @param jo A JSONObject
-     * @return A cookie list string
-     * @throws JSONException
-     */
-    public static String toString(JSONObject jo) throws JSONException {
-        boolean      b = false;
-        Iterator     keys = jo.keys();
-        String       string;
-        StringBuffer sb = new StringBuffer();
-        while (keys.hasNext()) {
-            string = keys.next().toString();
-            if (!jo.isNull(string)) {
-                if (b) {
-                    sb.append(';');
-                }
-                sb.append(Cookie.escape(string));
-                sb.append("=");
-                sb.append(Cookie.escape(jo.getString(string)));
-                b = true;
-            }
-        }
-        return sb.toString();
-    }
-}
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONString.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONString.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONString.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,18 +0,0 @@
-package org.json;
-/**
- * The <code>JSONString</code> interface allows a <code>toJSONString()</code> 
- * method so that a class can change the behavior of 
- * <code>JSONObject.toString()</code>, <code>JSONArray.toString()</code>,
- * and <code>JSONWriter.value(</code>Object<code>)</code>. The 
- * <code>toJSONString</code> method will be used instead of the default behavior 
- * of using the Object's <code>toString()</code> method and quoting the result.
- */
-public interface JSONString {
-	/**
-	 * The <code>toJSONString</code> method allows a class to produce its own JSON 
-	 * serialization. 
-	 * 
-	 * @return A strictly syntactically correct JSON text.
-	 */
-	public String toJSONString();
-}
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONWriter.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONWriter.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONWriter.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,323 +0,0 @@
-package org.json;
-
-import java.io.IOException;
-import java.io.Writer;
-
-/*
-Copyright (c) 2006 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-/**
- * JSONWriter provides a quick and convenient way of producing JSON text.
- * The texts produced strictly conform to JSON syntax rules. No whitespace is
- * added, so the results are ready for transmission or storage. Each instance of
- * JSONWriter can produce one JSON text.
- * <p>
- * A JSONWriter instance provides a <code>value</code> method for appending
- * values to the
- * text, and a <code>key</code>
- * method for adding keys before values in objects. There are <code>array</code>
- * and <code>endArray</code> methods that make and bound array values, and
- * <code>object</code> and <code>endObject</code> methods which make and bound
- * object values. All of these methods return the JSONWriter instance,
- * permitting a cascade style. For example, <pre>
- * new JSONWriter(myWriter)
- *     .object()
- *         .key("JSON")
- *         .value("Hello, World!")
- *     .endObject();</pre> which writes <pre>
- * {"JSON":"Hello, World!"}</pre>
- * <p>
- * The first method called must be <code>array</code> or <code>object</code>.
- * There are no methods for adding commas or colons. JSONWriter adds them for
- * you. Objects and arrays can be nested up to 20 levels deep.
- * <p>
- * This can sometimes be easier than using a JSONObject to build a string.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class JSONWriter {
-    private static final int maxdepth = 20;
-
-    /**
-     * The comma flag determines if a comma should be output before the next
-     * value.
-     */
-    private boolean comma;
-
-    /**
-     * The current mode. Values:
-     * 'a' (array),
-     * 'd' (done),
-     * 'i' (initial),
-     * 'k' (key),
-     * 'o' (object).
-     */
-    protected char mode;
-
-    /**
-     * The object/array stack.
-     */
-    private JSONObject stack[];
-
-    /**
-     * The stack top index. A value of 0 indicates that the stack is empty.
-     */
-    private int top;
-
-    /**
-     * The writer that will receive the output.
-     */
-    protected Writer writer;
-
-    /**
-     * Make a fresh JSONWriter. It can be used to build one JSON text.
-     */
-    public JSONWriter(Writer w) {
-        this.comma = false;
-        this.mode = 'i';
-        this.stack = new JSONObject[maxdepth];
-        this.top = 0;
-        this.writer = w;
-    }
-
-    /**
-     * Append a value.
-     * @param string A string value.
-     * @return this
-     * @throws JSONException If the value is out of sequence.
-     */
-    private JSONWriter append(String string) throws JSONException {
-        if (string == null) {
-            throw new JSONException("Null pointer");
-        }
-        if (this.mode == 'o' || this.mode == 'a') {
-            try {
-                if (this.comma && this.mode == 'a') {
-                    this.writer.write(',');
-                }
-                this.writer.write(string);
-            } catch (IOException e) {
-                throw new JSONException(e);
-            }
-            if (this.mode == 'o') {
-                this.mode = 'k';
-            }
-            this.comma = true;
-            return this;
-        }
-        throw new JSONException("Value out of sequence.");
-    }
-
-    /**
-     * Begin appending a new array. All values until the balancing
-     * <code>endArray</code> will be appended to this array. The
-     * <code>endArray</code> method must be called to mark the array's end.
-     * @return this
-     * @throws JSONException If the nesting is too deep, or if the object is
-     * started in the wrong place (for example as a key or after the end of the
-     * outermost array or object).
-     */
-    public JSONWriter array() throws JSONException {
-        if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {
-            this.push(null);
-            this.append("[");
-            this.comma = false;
-            return this;
-        }
-        throw new JSONException("Misplaced array.");
-    }
-
-    /**
-     * End something.
-     * @param mode Mode
-     * @param c Closing character
-     * @return this
-     * @throws JSONException If unbalanced.
-     */
-    private JSONWriter end(char mode, char c) throws JSONException {
-        if (this.mode != mode) {
-            throw new JSONException(mode == 'a' ? "Misplaced endArray." : 
-            		"Misplaced endObject.");
-        }
-        this.pop(mode);
-        try {
-            this.writer.write(c);
-        } catch (IOException e) {
-            throw new JSONException(e);
-        }
-        this.comma = true;
-        return this;
-    }
-
-    /**
-     * End an array. This method most be called to balance calls to
-     * <code>array</code>.
-     * @return this
-     * @throws JSONException If incorrectly nested.
-     */
-    public JSONWriter endArray() throws JSONException {
-        return this.end('a', ']');
-    }
-
-    /**
-     * End an object. This method most be called to balance calls to
-     * <code>object</code>.
-     * @return this
-     * @throws JSONException If incorrectly nested.
-     */
-    public JSONWriter endObject() throws JSONException {
-        return this.end('k', '}');
-    }
-
-    /**
-     * Append a key. The key will be associated with the next value. In an
-     * object, every value must be preceded by a key.
-     * @param string A key string.
-     * @return this
-     * @throws JSONException If the key is out of place. For example, keys
-     *  do not belong in arrays or if the key is null.
-     */
-    public JSONWriter key(String string) throws JSONException {
-        if (string == null) {
-            throw new JSONException("Null key.");
-        }
-        if (this.mode == 'k') {
-            try {
-                stack[top - 1].putOnce(string, Boolean.TRUE);
-                if (this.comma) {
-                    this.writer.write(',');
-                }
-                this.writer.write(JSONObject.quote(string));
-                this.writer.write(':');
-                this.comma = false;
-                this.mode = 'o';
-                return this;
-            } catch (IOException e) {
-                throw new JSONException(e);
-            }
-        }
-        throw new JSONException("Misplaced key.");
-    }
-
-
-    /**
-     * Begin appending a new object. All keys and values until the balancing
-     * <code>endObject</code> will be appended to this object. The
-     * <code>endObject</code> method must be called to mark the object's end.
-     * @return this
-     * @throws JSONException If the nesting is too deep, or if the object is
-     * started in the wrong place (for example as a key or after the end of the
-     * outermost array or object).
-     */
-    public JSONWriter object() throws JSONException {
-        if (this.mode == 'i') {
-            this.mode = 'o';
-        }
-        if (this.mode == 'o' || this.mode == 'a') {
-            this.append("{");
-            this.push(new JSONObject());
-            this.comma = false;
-            return this;
-        }
-        throw new JSONException("Misplaced object.");
-
-    }
-
-
-    /**
-     * Pop an array or object scope.
-     * @param c The scope to close.
-     * @throws JSONException If nesting is wrong.
-     */
-    private void pop(char c) throws JSONException {
-        if (this.top <= 0) {
-            throw new JSONException("Nesting error.");
-        }
-        char m = this.stack[this.top - 1] == null ? 'a' : 'k';
-        if (m != c) {
-            throw new JSONException("Nesting error.");
-        }
-        this.top -= 1;
-        this.mode = this.top == 0 ? 
-        		'd' : this.stack[this.top - 1] == null ? 'a' : 'k';
-    }
-
-    /**
-     * Push an array or object scope.
-     * @param c The scope to open.
-     * @throws JSONException If nesting is too deep.
-     */
-    private void push(JSONObject jo) throws JSONException {
-        if (this.top >= maxdepth) {
-            throw new JSONException("Nesting too deep.");
-        }
-        this.stack[this.top] = jo;
-        this.mode = jo == null ? 'a' : 'k';
-        this.top += 1;
-    }
-
-
-    /**
-     * Append either the value <code>true</code> or the value
-     * <code>false</code>.
-     * @param b A boolean.
-     * @return this
-     * @throws JSONException
-     */
-    public JSONWriter value(boolean b) throws JSONException {
-        return this.append(b ? "true" : "false");
-    }
-
-    /**
-     * Append a double value.
-     * @param d A double.
-     * @return this
-     * @throws JSONException If the number is not finite.
-     */
-    public JSONWriter value(double d) throws JSONException {
-        return this.value(new Double(d));
-    }
-
-    /**
-     * Append a long value.
-     * @param l A long.
-     * @return this
-     * @throws JSONException
-     */
-    public JSONWriter value(long l) throws JSONException {
-        return this.append(Long.toString(l));
-    }
-
-
-    /**
-     * Append an object value.
-     * @param object The object to append. It can be null, or a Boolean, Number,
-     *   String, JSONObject, or JSONArray, or an object that implements JSONString.
-     * @return this
-     * @throws JSONException If the value is out of sequence.
-     */
-    public JSONWriter value(Object object) throws JSONException {
-        return this.append(JSONObject.valueToString(object));
-    }
-}
Index: out/production/OOP_EX2/annotations-13.0.jar/META-INF/MANIFEST.MF
===================================================================
--- out/production/OOP_EX2/annotations-13.0.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/annotations-13.0.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,6 +0,0 @@
-Manifest-Version: 1.0
-Archiver-Version: Plexus Archiver
-Created-By: Apache Maven
-Built-By: jetbrains
-Build-Jdk: 1.6.0_65
-
Index: out/production/OOP_EX2/java-json.jar/org/json/JSONStringer.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/JSONStringer.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/JSONStringer.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,78 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2006 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-import java.io.StringWriter;
-
-/**
- * JSONStringer provides a quick and convenient way of producing JSON text.
- * The texts produced strictly conform to JSON syntax rules. No whitespace is
- * added, so the results are ready for transmission or storage. Each instance of
- * JSONStringer can produce one JSON text.
- * <p>
- * A JSONStringer instance provides a <code>value</code> method for appending
- * values to the
- * text, and a <code>key</code>
- * method for adding keys before values in objects. There are <code>array</code>
- * and <code>endArray</code> methods that make and bound array values, and
- * <code>object</code> and <code>endObject</code> methods which make and bound
- * object values. All of these methods return the JSONWriter instance,
- * permitting cascade style. For example, <pre>
- * myString = new JSONStringer()
- *     .object()
- *         .key("JSON")
- *         .value("Hello, World!")
- *     .endObject()
- *     .toString();</pre> which produces the string <pre>
- * {"JSON":"Hello, World!"}</pre>
- * <p>
- * The first method called must be <code>array</code> or <code>object</code>.
- * There are no methods for adding commas or colons. JSONStringer adds them for
- * you. Objects and arrays can be nested up to 20 levels deep.
- * <p>
- * This can sometimes be easier than using a JSONObject to build a string.
- * @author JSON.org
- * @version 2008-09-18
- */
-public class JSONStringer extends JSONWriter {
-    /**
-     * Make a fresh JSONStringer. It can be used to build one JSON text.
-     */
-    public JSONStringer() {
-        super(new StringWriter());
-    }
-
-    /**
-     * Return the JSON text. This method is used to obtain the product of the
-     * JSONStringer instance. It will return <code>null</code> if there was a
-     * problem in the construction of the JSON text (such as the calls to
-     * <code>array</code> were not properly balanced with calls to
-     * <code>endArray</code>).
-     * @return The JSON text.
-     */
-    public String toString() {
-        return this.mode == 'd' ? this.writer.toString() : null;
-    }
-}
Index: .idea/libraries/annotations_13_0.xml
===================================================================
--- .idea/libraries/annotations_13_0.xml	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ .idea/libraries/annotations_13_0.xml	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,7 +0,0 @@
-<component name="libraryTable">
-  <library name="annotations-13.0">
-    <CLASSES />
-    <JAVADOC />
-    <SOURCES />
-  </library>
-</component>
\ No newline at end of file
Index: out/production/OOP_EX2/okio-2.7.0.jar/META-INF/proguard/okio.pro
===================================================================
--- out/production/OOP_EX2/okio-2.7.0.jar/META-INF/proguard/okio.pro	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/okio-2.7.0.jar/META-INF/proguard/okio.pro	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,2 +0,0 @@
-# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
--dontwarn org.codehaus.mojo.animal_sniffer.*
Index: out/production/OOP_EX2/okhttp-4.8.0.jar/META-INF/MANIFEST.MF
===================================================================
--- out/production/OOP_EX2/okhttp-4.8.0.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/okhttp-4.8.0.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,3 +0,0 @@
-Manifest-Version: 1.0
-Automatic-Module-Name: okhttp3
-
Index: out/production/OOP_EX2/java-json.jar/META-INF/MANIFEST.MF
===================================================================
--- out/production/OOP_EX2/java-json.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/META-INF/MANIFEST.MF	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,3 +0,0 @@
-Manifest-Version: 1.0
-Created-By: 1.6.0_18 (Sun Microsystems Inc.)
-
Index: out/production/OOP_EX2/annotations-13.0.jar/META-INF/maven/org.jetbrains/annotations/pom.xml
===================================================================
--- out/production/OOP_EX2/annotations-13.0.jar/META-INF/maven/org.jetbrains/annotations/pom.xml	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/annotations-13.0.jar/META-INF/maven/org.jetbrains/annotations/pom.xml	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,139 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project
-        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
-        xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
-
-    <modelVersion>4.0.0</modelVersion>
-
-    <groupId>org.jetbrains</groupId>
-    <artifactId>annotations</artifactId>
-    <version>13.0</version>
-    <packaging>jar</packaging>
-
-    <name>IntelliJ IDEA Annotations</name>
-    <description>A set of annotations used for code inspection support and code documentation.</description>
-    <url>http://www.jetbrains.org</url>
-
-    <licenses>
-        <license>
-            <name>The Apache Software License, Version 2.0</name>
-            <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-            <distribution>repo</distribution>
-            <comments>A business-friendly OSS license</comments>
-        </license>
-    </licenses>
-
-    <scm>
-        <url>https://github.com/JetBrains/intellij-community</url>
-        <connection>scm:git:https://github.com/JetBrains/intellij-community.git</connection>
-    </scm>
-
-    <developers>
-        <developer>
-            <id>JetBrains</id>
-            <name>JetBrains Team</name>
-            <organization>JetBrains</organization>
-            <organizationUrl>http://www.jetbrains.com</organizationUrl>
-        </developer>
-    </developers>
-
-    <properties>
-        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-    </properties>
-
-    <build>
-        <plugins>
-            <plugin>
-                <artifactId>maven-antrun-plugin</artifactId>
-                <version>1.7</version>
-                <executions>
-                    <execution>
-                        <phase>generate-sources</phase>
-                        <configuration>
-                            <tasks>
-                                <delete dir="${basedir}/src/main/java" />
-                                <mkdir dir="${basedir}/src/main/java" />
-                                <copy todir="${basedir}/src/main/java">
-                                    <fileset dir="${basedir}/../../../community/platform/annotations/src" />
-                                </copy>
-                            </tasks>
-                        </configuration>
-                        <goals>
-                            <goal>run</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-source-plugin</artifactId>
-                <version>2.1.2</version>
-
-                <executions>
-                    <execution>
-                        <id>attach-sources</id>
-                        <goals>
-                            <goal>jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
-                <configuration>
-                    <source>1.5</source>
-                    <target>1.5</target>
-                </configuration>
-            </plugin>
-
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.9.1</version>
-                <executions>
-                    <execution>
-                        <id>attach-javadocs</id>
-                        <goals>
-                            <goal>jar</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-
-            <plugin>
-                <artifactId>maven-gpg-plugin</artifactId>
-                <version>1.4</version>
-                <configuration>
-                    <keyname>66770193</keyname>
-                    <homedir>${basedir}/.gnupg</homedir>
-                </configuration>
-                <executions>
-                    <execution>
-                        <id>sign-artifacts</id>
-                        <phase>verify</phase>
-                        <goals>
-                            <goal>sign</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
-
-        </plugins>
-    </build>
-
-    <distributionManagement>
-        <repository>
-            <id>sonatype-nexus-staging</id>
-            <url>http://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
-        </repository>
-        <snapshotRepository>
-            <id>sonatype-nexus-snapshots</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots/</url>
-        </snapshotRepository>
-    </distributionManagement>
-
-</project>
Index: out/production/OOP_EX2/java-json.jar/org/json/HTTP.java
===================================================================
--- out/production/OOP_EX2/java-json.jar/org/json/HTTP.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ out/production/OOP_EX2/java-json.jar/org/json/HTTP.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
@@ -1,163 +0,0 @@
-package org.json;
-
-/*
-Copyright (c) 2002 JSON.org
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-The Software shall be used for Good, not Evil.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-import java.util.Iterator;
-
-/**
- * Convert an HTTP header to a JSONObject and back.
- * @author JSON.org
- * @version 2010-12-24
- */
-public class HTTP {
-
-    /** Carriage return/line feed. */
-    public static final String CRLF = "\r\n";
-
-    /**
-     * Convert an HTTP header string into a JSONObject. It can be a request
-     * header or a response header. A request header will contain
-     * <pre>{
-     *    Method: "POST" (for example),
-     *    "Request-URI": "/" (for example),
-     *    "HTTP-Version": "HTTP/1.1" (for example)
-     * }</pre>
-     * A response header will contain
-     * <pre>{
-     *    "HTTP-Version": "HTTP/1.1" (for example),
-     *    "Status-Code": "200" (for example),
-     *    "Reason-Phrase": "OK" (for example)
-     * }</pre>
-     * In addition, the other parameters in the header will be captured, using
-     * the HTTP field names as JSON names, so that <pre>
-     *    Date: Sun, 26 May 2002 18:06:04 GMT
-     *    Cookie: Q=q2=PPEAsg--; B=677gi6ouf29bn&b=2&f=s
-     *    Cache-Control: no-cache</pre>
-     * become
-     * <pre>{...
-     *    Date: "Sun, 26 May 2002 18:06:04 GMT",
-     *    Cookie: "Q=q2=PPEAsg--; B=677gi6ouf29bn&b=2&f=s",
-     *    "Cache-Control": "no-cache",
-     * ...}</pre>
-     * It does no further checking or conversion. It does not parse dates.
-     * It does not do '%' transforms on URLs.
-     * @param string An HTTP header string.
-     * @return A JSONObject containing the elements and attributes
-     * of the XML string.
-     * @throws JSONException
-     */
-    public static JSONObject toJSONObject(String string) throws JSONException {
-        JSONObject     jo = new JSONObject();
-        HTTPTokener    x = new HTTPTokener(string);
-        String         token;
-
-        token = x.nextToken();
-        if (token.toUpperCase().startsWith("HTTP")) {
-
-// Response
-
-            jo.put("HTTP-Version", token);
-            jo.put("Status-Code", x.nextToken());
-            jo.put("Reason-Phrase", x.nextTo('\0'));
-            x.next();
-
-        } else {
-
-// Request
-
-            jo.put("Method", token);
-            jo.put("Request-URI", x.nextToken());
-            jo.put("HTTP-Version", x.nextToken());
-        }
-
-// Fields
-
-        while (x.more()) {
-            String name = x.nextTo(':');
-            x.next(':');
-            jo.put(name, x.nextTo('\0'));
-            x.next();
-        }
-        return jo;
-    }
-
-
-    /**
-     * Convert a JSONObject into an HTTP header. A request header must contain
-     * <pre>{
-     *    Method: "POST" (for example),
-     *    "Request-URI": "/" (for example),
-     *    "HTTP-Version": "HTTP/1.1" (for example)
-     * }</pre>
-     * A response header must contain
-     * <pre>{
-     *    "HTTP-Version": "HTTP/1.1" (for example),
-     *    "Status-Code": "200" (for example),
-     *    "Reason-Phrase": "OK" (for example)
-     * }</pre>
-     * Any other members of the JSONObject will be output as HTTP fields.
-     * The result will end with two CRLF pairs.
-     * @param jo A JSONObject
-     * @return An HTTP header string.
-     * @throws JSONException if the object does not contain enough
-     *  information.
-     */
-    public static String toString(JSONObject jo) throws JSONException {
-        Iterator     keys = jo.keys();
-        String       string;
-        StringBuffer sb = new StringBuffer();
-        if (jo.has("Status-Code") && jo.has("Reason-Phrase")) {
-            sb.append(jo.getString("HTTP-Version"));
-            sb.append(' ');
-            sb.append(jo.getString("Status-Code"));
-            sb.append(' ');
-            sb.append(jo.getString("Reason-Phrase"));
-        } else if (jo.has("Method") && jo.has("Request-URI")) {
-            sb.append(jo.getString("Method"));
-            sb.append(' ');
-            sb.append('"');
-            sb.append(jo.getString("Request-URI"));
-            sb.append('"');
-            sb.append(' ');
-            sb.append(jo.getString("HTTP-Version"));
-        } else {
-            throw new JSONException("Not enough material for an HTTP header.");
-        }
-        sb.append(CRLF);
-        while (keys.hasNext()) {
-            string = keys.next().toString();
-            if (!string.equals("HTTP-Version")      && !string.equals("Status-Code") &&
-                    !string.equals("Reason-Phrase") && !string.equals("Method") &&
-                    !string.equals("Request-URI")   && !jo.isNull(string)) {
-                sb.append(string);
-                sb.append(": ");
-                sb.append(jo.getString(string));
-                sb.append(CRLF);
-            }
-        }
-        sb.append(CRLF);
-        return sb.toString();
-    }
-}
Index: .idea/libraries/lib2.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/lib2.xml	(date 1608405706822)
+++ .idea/libraries/lib2.xml	(date 1608405706822)
@@ -0,0 +1,15 @@
+<component name="libraryTable">
+  <library name="lib">
+    <CLASSES>
+      <root url="jar://$PROJECT_DIR$/lib/kotlin-stdlib-1.3.72.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/kotlin-stdlib-common-1.3.70.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/Ex2_Server_v0.13.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/okio-2.7.0.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/annotations-13.0.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/java-json.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/okhttp-4.8.0.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES />
+  </library>
+</component>
\ No newline at end of file
Index: .idea/libraries/OOP_EX22.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/OOP_EX22.xml	(date 1608405706798)
+++ .idea/libraries/OOP_EX22.xml	(date 1608405706798)
@@ -0,0 +1,9 @@
+<component name="libraryTable">
+  <library name="OOP_EX2">
+    <CLASSES>
+      <root url="jar://$PROJECT_DIR$/out/artifacts/OOP_EX2_jar/OOP_EX2.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES />
+  </library>
+</component>
\ No newline at end of file
Index: .idea/libraries/lib.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/lib.xml	(date 1608405706811)
+++ .idea/libraries/lib.xml	(date 1608405706811)
@@ -0,0 +1,15 @@
+<component name="libraryTable">
+  <library name="lib">
+    <CLASSES>
+      <root url="jar://$PROJECT_DIR$/lib/kotlin-stdlib-1.3.72.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/kotlin-stdlib-common-1.3.70.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/Ex2_Server_v0.13.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/okio-2.7.0.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/annotations-13.0.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/java-json.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lib/okhttp-4.8.0.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES />
+  </library>
+</component>
\ No newline at end of file
Index: src/META-INF/MANIFEST.MF
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/META-INF/MANIFEST.MF	(date 1608403728608)
+++ src/META-INF/MANIFEST.MF	(date 1608403728608)
@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+Main-Class: gameClient.Ex2
+
Index: .idea/libraries/OOP_EX2.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/OOP_EX2.xml	(date 1608405706787)
+++ .idea/libraries/OOP_EX2.xml	(date 1608405706787)
@@ -0,0 +1,9 @@
+<component name="libraryTable">
+  <library name="OOP_EX2">
+    <CLASSES>
+      <root url="jar://$PROJECT_DIR$/out/artifacts/OOP_EX2_jar/OOP_EX2.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES />
+  </library>
+</component>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_15_PREVIEW\" default=\"false\" project-jdk-name=\"15\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ .idea/misc.xml	(date 1608405706723)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_15_PREVIEW" default="false" project-jdk-name="15" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_15" project-jdk-name="15" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
 </project>
\ No newline at end of file
Index: OOP_EX2.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"JAVA_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\r\n    <exclude-output />\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/src\" isTestSource=\"false\" />\r\n      <sourceFolder url=\"file://$MODULE_DIR$/test\" isTestSource=\"true\" />\r\n      <sourceFolder url=\"file://$MODULE_DIR$/lib\" type=\"java-resource\" />\r\n    </content>\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n    <orderEntry type=\"library\" name=\"annotations-13.0\" level=\"project\" />\r\n    <orderEntry type=\"module-library\">\r\n      <library>\r\n        <CLASSES>\r\n          <root url=\"jar://$USER_HOME$/Downloads/java-json.jar!/\" />\r\n        </CLASSES>\r\n        <JAVADOC />\r\n        <SOURCES>\r\n          <root url=\"jar://$USER_HOME$/Downloads/java-json.jar!/\" />\r\n        </SOURCES>\r\n      </library>\r\n    </orderEntry>\r\n    <orderEntry type=\"module-library\">\r\n      <library>\r\n        <CLASSES>\r\n          <root url=\"jar://$USER_HOME$/Downloads/Ex2_Server_v0.13.jar!/\" />\r\n        </CLASSES>\r\n        <JAVADOC />\r\n        <SOURCES />\r\n      </library>\r\n    </orderEntry>\r\n    <orderEntry type=\"library\" name=\"lib\" level=\"project\" />\r\n    <orderEntry type=\"module-library\" scope=\"TEST\">\r\n      <library name=\"JUnit5.4\">\r\n        <CLASSES>\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.4.2/junit-jupiter-5.4.2.jar!/\" />\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.4.2/junit-jupiter-api-5.4.2.jar!/\" />\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.0.0/apiguardian-api-1.0.0.jar!/\" />\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.1.1/opentest4j-1.1.1.jar!/\" />\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.4.2/junit-platform-commons-1.4.2.jar!/\" />\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.4.2/junit-jupiter-params-5.4.2.jar!/\" />\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.4.2/junit-jupiter-engine-5.4.2.jar!/\" />\r\n          <root url=\"jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.4.2/junit-platform-engine-1.4.2.jar!/\" />\r\n        </CLASSES>\r\n        <JAVADOC />\r\n        <SOURCES />\r\n      </library>\r\n    </orderEntry>\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- OOP_EX2.iml	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ OOP_EX2.iml	(date 1608405829555)
@@ -5,31 +5,10 @@
     <content url="file://$MODULE_DIR$">
       <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
       <sourceFolder url="file://$MODULE_DIR$/test" isTestSource="true" />
-      <sourceFolder url="file://$MODULE_DIR$/lib" type="java-resource" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="library" name="annotations-13.0" level="project" />
-    <orderEntry type="module-library">
-      <library>
-        <CLASSES>
-          <root url="jar://$USER_HOME$/Downloads/java-json.jar!/" />
-        </CLASSES>
-        <JAVADOC />
-        <SOURCES>
-          <root url="jar://$USER_HOME$/Downloads/java-json.jar!/" />
-        </SOURCES>
-      </library>
-    </orderEntry>
-    <orderEntry type="module-library">
-      <library>
-        <CLASSES>
-          <root url="jar://$USER_HOME$/Downloads/Ex2_Server_v0.13.jar!/" />
-        </CLASSES>
-        <JAVADOC />
-        <SOURCES />
-      </library>
-    </orderEntry>
+    <orderEntry type="library" name="lib" level="project" />
     <orderEntry type="library" name="lib" level="project" />
     <orderEntry type="module-library" scope="TEST">
       <library name="JUnit5.4">
Index: src/gameClient/Ex2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package gameClient;\r\n\r\nimport Server.Game_Server_Ex2;\r\nimport api.*;\r\nimport org.json.JSONArray;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport javax.sound.sampled.LineUnavailableException;\r\nimport javax.sound.sampled.UnsupportedAudioFileException;\r\nimport javax.swing.*;\r\nimport java.io.IOException;\r\nimport java.util.*;\r\n\r\npublic class Ex2 implements Runnable {\r\n\r\n    public static void main(String[] args) throws UnsupportedAudioFileException, IOException, LineUnavailableException, InterruptedException {\r\n\r\n//        if(args[0]!=null && args[1]!=null) {\r\n//            Ex2 ex2 = new Ex2();\r\n//            ex2.setGameNumber(Integer.parseInt(args[1]));\r\n//            ex2.setID(Integer.parseInt(args[0]));\r\n//            Thread game_thread = new Thread(ex2);\r\n//            game_thread.start();\r\n//        }\r\n//        else {\r\n//            LoginFrame login = new LoginFrame();\r\n//            login.setVisible(true);\r\n            Ex2 ex2 = new Ex2();\r\n            ex2.setGameNumber(3);\r\n            Thread game =new Thread(ex2);\r\n            game.start();\r\n        //}\r\n    }\r\n    private static final double EPS = 0.000001;\r\n    static int sumPokemons;\r\n    static boolean logged_in;\r\n    static int sumAgents;\r\n    static dw_graph_algorithms graphAL;\r\n    static directed_weighted_graph graphDS;\r\n    static List<Pokemon> pokemonList;\r\n    static List<Agent> agentList;\r\n    static List<String> GameInfo;\r\n    static String path;\r\n    private game_service game;\r\n    private long min;\r\n    private static GameFrame _win;\r\n    private static GameData _ar;\r\n    private int GameNumber;\r\n    private int ID;\r\n    public static Ex2 ex2;\r\n    // One more Data Structure min-heap for high value pokemons\r\n    // To set the agents next to high value pokemons in the start\r\n    private static PriorityQueue<Pokemon> highValuePokemon = new PriorityQueue<>(2, new Comparator<Pokemon>() {\r\n        @Override\r\n        public int compare(Pokemon o1, Pokemon o2) {\r\n            if(o1.getValue()<o2.getValue())\r\n                return 1;\r\n            else if(o1.getValue()>o2.getValue())\r\n                return  -1;\r\n            else\r\n                return 0;\r\n        }\r\n    });\r\n\r\n    @Override\r\n    public void run() {\r\n        int level_number = 0;\r\n        game = Game_Server_Ex2.getServer(GameNumber);\r\n        initTheGame(game);\r\n        try {\r\n            RunningTheGame(game);\r\n        } catch (JSONException | InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private void initTheGame(game_service game) {\r\n        min = Long.MAX_VALUE;\r\n        graphAL = new DWGraph_Algo();\r\n        graphDS = new DWGraph_DS();\r\n        pokemonList = new LinkedList<>();\r\n        agentList = new LinkedList<>();\r\n        GameInfo = new LinkedList<>();\r\n        UpdateGameInfo(GameNumber, 0, 0);\r\n        try {\r\n            getGameData(game);\r\n            graphAL.load(path);\r\n            graphDS = graphAL.getGraph();\r\n            updatePokemonList(game);\r\n            _ar = new GameData(graphDS, agentList, pokemonList, GameInfo);\r\n//            if(sumAgents==1 && pokemonList.size()>1)\r\n//                setPlaceOfAgentsHighValue(game);\r\n//            else setPlaceOfAgents(game);\r\n            setPlaceOfAgents(game);\r\n            _ar = new GameData(graphDS, agentList, pokemonList,GameInfo);\r\n            _win = new GameFrame(\"test Ex2\");\r\n            _win.setSize(1000, 700);\r\n            _win.update(_ar);\r\n            _win.setVisible(true);\r\n            _win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n            //game.login(20);\r\n            game.startGame();\r\n            _win.setTitle(\"Ex2 - OOP: \" + GameNumber);\r\n            setPokToEachAgent(game);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static void UpdateGameInfo(int level, long time, double value) {\r\n        List<String> newList = new LinkedList<>();\r\n        newList.add(String.valueOf(level));\r\n        newList.add(String.valueOf(time / 1000));\r\n        newList.add(String.valueOf(value));\r\n        GameInfo = newList;\r\n    }\r\n\r\n    private static void regfreshLocation(String s) throws JSONException {\r\n        JSONObject obj = new JSONObject(s);\r\n        JSONArray moveData = obj.getJSONArray(\"Agents\");\r\n        for (int i = 0; i < moveData.length(); i++) {\r\n            JSONObject agent = moveData.getJSONObject(i).getJSONObject(\"Agent\");\r\n            Agent a = new Agent(agent);\r\n            for (Agent ag : agentList) {\r\n                if (ag.getId() == a.getId()) {\r\n                    ag.setPos(a.getPos());\r\n                    ag.setDest(a.getDest());\r\n                    ag.setSrc(a.getSrc());\r\n                    ag.setSpeed(a.getSpeed());\r\n                    ag.setValue(a.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void updatePoks(String pokemons) throws JSONException {\r\n        List<Pokemon> newP = new LinkedList<>();\r\n        JSONObject newPokemonsObj = new JSONObject(pokemons);\r\n        JSONArray pokemonsArr = newPokemonsObj.getJSONArray(\"Pokemons\");\r\n        for (int i = 0; i < pokemonsArr.length(); i++) {\r\n            Pokemon pok = new Pokemon(pokemonsArr.getJSONObject(i).getJSONObject(\"Pokemon\"));\r\n            boolean connectToAgent = false;\r\n            for (int j = 0; j < agentList.size(); j++) {\r\n                List<Pokemon> poks = agentList.get(j).getMyPoks();\r\n                List<Pokemon> poksToRemove = new LinkedList<>();\r\n                for (Pokemon p : poks) {\r\n                    if (!p.is_in_the_game(pokemons, p))\r\n                        poksToRemove.add(p);\r\n                }\r\n                poks.removeAll(poksToRemove);\r\n                for (Pokemon p : poks) {\r\n                    if (p != null) {\r\n                        geo_location pokL = pok.getPos();\r\n                        geo_location PL = p.getPos();\r\n                        if (pokL.x() == PL.x() && pokL.y() == PL.y() && pokL.z() == PL.z()) {\r\n                            connectToAgent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n            //boolean ans = is_in_the_way(pok);\r\n            if (!connectToAgent) {\r\n                setSrcAndDest(pok);\r\n                edgeData e = (edgeData) (graphDS.getEdge(pok.src, pok.dest));\r\n                edgeData.edgeLocation edgelocation = new edgeData.edgeLocation(pok.getPos(), e);\r\n                pok.setEL(edgelocation);\r\n                newP.add(pok);\r\n            }\r\n        }\r\n        pokemonList = newP;\r\n    }\r\n//    private static boolean isOnTheWay(Pokemon p) {\r\n//        for (Agent agent : agentList) {\r\n//            if(agent.getMyPath().isEmpty())\r\n//                break;\r\n//            int stopSign = agent.getMyPath().poll();\r\n//            int[] arrayPath = new int[agent.getMyPath().size()];\r\n//            int n = stopSign;\r\n//            int index = 0;\r\n//            do {\r\n//                arrayPath[index] = n;\r\n//                index++;\r\n//                agent.getMyPath().add(n);\r\n//                n = agent.myPath.poll();\r\n//            }\r\n//            while (n != stopSign);\r\n//\r\n//            for (int i = 0; i < arrayPath.length - 1; i++) {\r\n//                if ((p.getSrc() == arrayPath[i]) && (p.getDest() == arrayPath[i + 1]))\r\n//                    return true;\r\n//            }\r\n//        }\r\n//        return false;\r\n//    }\r\n\r\n//    public static boolean is_in_the_way(Pokemon p) {\r\n//        boolean ans = false;\r\n//        for (Agent a : agentList) {\r\n//            if (a.getMyPath().size() < 2)\r\n//                break;\r\n//            Queue<Integer> path = new LinkedList<>();\r\n//            path = a.getMyPath();\r\n//\r\n//            int src = path.poll(), dest = path.poll();\r\n//            System.out.println(\"src: \"+src);\r\n//            System.out.println(\"dest: \"+dest);\r\n//            do {\r\n//                System.out.println(\"que: \"+path);\r\n//                if (p.getSrc() == src && p.getDest() == dest) {\r\n//                    p.setAgent(a);\r\n//                    a.getMyPoks().add(p);\r\n//                    return true;\r\n//                } else {\r\n//                    src = dest;\r\n//                    dest = path.poll();\r\n//                }\r\n//            } while (!path.isEmpty());\r\n//        }\r\n//        return ans;\r\n//    }\r\n\r\n\r\n\r\n\r\n    private void RunningTheGame(game_service game) throws JSONException, InterruptedException {\r\n        int count = 0;\r\n        int sum = 0;\r\n        boolean mark=false;\r\n        double TotalValue = 0;\r\n        String s;\r\n        while (game.isRunning()) {\r\n            min = Long.MAX_VALUE;\r\n            s = game.move();\r\n            //count++;\r\n            //System.out.println(count);\r\n            regfreshLocation(s);\r\n            UpdateGameInfo(GameNumber, game.timeToEnd(), TotalValue);\r\n            _ar.setAgents(agentList);\r\n            _ar.setPokemons(poks_in_the_game(game.getPokemons()));\r\n            _ar.set_info(GameInfo);\r\n            _win.repaint();\r\n            TotalValue = 0;\r\n            for (Agent a : agentList) {\r\n                mark=false;\r\n                int tmp = a.getDest();\r\n                if (a.getDest() == -1 ) {\r\n                    String poks= game.getPokemons();\r\n                    if (!a.pokemon.is_in_the_game(poks,a.getPokemon())) { //a took the pokemon\r\n                        updatePoks(poks);\r\n                        a.findClosestPokemon(graphAL, pokemonList);\r\n                    }\r\n                    game.chooseNextEdge(a.getId(), a.getNextDest());\r\n                }\r\n                else{\r\n                    for (Pokemon p: a.getMyPoks())\r\n                    {\r\n                     if(a.getPos().distance(p.getPos())<0.00001) {\r\n                         mark = true;\r\n                         break;\r\n                     }\r\n                    }\r\n                    if(mark) {\r\n                        updatePoks(game.getPokemons());\r\n                    }\r\n                }\r\n                long time = a.time(graphDS, tmp, game.getPokemons(), pokemonList);\r\n                min = (time < min && time != 0) ? time : min;\r\n                TotalValue += a.getValue();\r\n            }\r\n            if (min == Long.MAX_VALUE) {\r\n                min = 1;\r\n            }\r\n\r\n            Thread.sleep(min);\r\n        }\r\n        _win.dispose();\r\n        System.out.println(game.toString());\r\n    }\r\n\r\n    public static List<Pokemon> poks_in_the_game(String pokemons) throws JSONException {\r\n        JSONObject newPokemonsObj = new JSONObject(pokemons);\r\n        JSONArray pokemonsArr = newPokemonsObj.getJSONArray(\"Pokemons\");\r\n        List<Pokemon> p = new LinkedList<>();\r\n        for (int i = 0; i < pokemonsArr.length(); i++) {\r\n            Pokemon newPok = new Pokemon(pokemonsArr.getJSONObject(i).getJSONObject(\"Pokemon\"));\r\n            p.add(newPok);\r\n        }\r\n        return p;\r\n    }\r\n\r\n    private static void updatePokemonList(game_service game) throws JSONException {\r\n        List<Pokemon> newP = new LinkedList<>();\r\n        JSONObject pokemons = new JSONObject(game.getPokemons());\r\n        JSONArray pokemonArr = pokemons.getJSONArray(\"Pokemons\");\r\n        for (int i = 0; i < pokemonArr.length(); i++) {\r\n            Pokemon pok = new Pokemon(pokemonArr.getJSONObject(i).getJSONObject(\"Pokemon\"));\r\n            setSrcAndDest(pok);\r\n            edgeData e = (edgeData) (graphDS.getEdge(pok.src, pok.dest));\r\n            edgeData.edgeLocation edgelocation = new edgeData.edgeLocation(pok.getPos(), e);\r\n            pok.setEL(edgelocation);\r\n            newP.add(pok);\r\n        }\r\n        pokemonList = newP;\r\n    }\r\n\r\n    private static void setPlaceOfAgents(game_service game) {\r\n        for (int i = 0; i < sumAgents; i++) {\r\n            if (i < pokemonList.size()) {\r\n                game.addAgent(pokemonList.get(i).getSrc());\r\n            } else\r\n                game.addAgent(graphDS.getV().stream().findFirst().get().getKey());\r\n        }\r\n    }\r\n    private static void setThePQ() {\r\n        for(Pokemon p:pokemonList)\r\n            highValuePokemon.add(p);\r\n    }\r\n    private static void setPlaceOfAgentsHighValue (game_service game)\r\n    {\r\n        setThePQ();\r\n        for (int i = 0; i < sumAgents; i++) {\r\n            if (i < highValuePokemon.size()) {\r\n                game.addAgent(highValuePokemon.poll().src);\r\n            } else\r\n                game.addAgent(graphDS.getV().stream().findFirst().get().getKey());\r\n        }\r\n    }\r\n\r\n//    public void setPokToEachAgent(game_service game) throws JSONException {\r\n//        createAgentsList(game);\r\n//        for (Agent a : agentList) {\r\n//            a.findClosestPokemon(graphAL, pokemonList);\r\n//            game.chooseNextEdge(a.getId(), a.getNextDest());\r\n//        }\r\n//    }\r\n\r\n    public void setPokToEachAgent (game_service game) throws JSONException {\r\n        createAgentsList(game);\r\n        for (Agent a : agentList) {\r\n            for (Pokemon p : pokemonList) {\r\n                if ((p.getSrc() == a.getSrc()) && (p.getAgent() == null)) {\r\n                    a.setPokemon(p);\r\n                    a.getMyPoks().add(p);\r\n                    p.setAgent(a);\r\n                    a.setDest(a.getPokemon().getDest());\r\n                    game.chooseNextEdge(a.getId(), a.getPokemon().getDest());\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void createAgentsList(game_service game) throws JSONException {\r\n        JSONObject agents = new JSONObject(game.getAgents());\r\n        JSONArray agentsArr = agents.getJSONArray(\"Agents\");\r\n        for (int i = 0; i < agentsArr.length(); i++) {\r\n            Agent ag = new Agent(agentsArr.getJSONObject(i).getJSONObject(\"Agent\"));\r\n            agentList.add(ag);\r\n        }\r\n    }\r\n\r\n    private static void getGameData(game_service game) throws JSONException {\r\n        JSONObject gameServer = new JSONObject(game.toString());\r\n        JSONObject gameData = gameServer.getJSONObject(\"GameServer\");\r\n        sumAgents = gameData.getInt(\"agents\");\r\n        sumPokemons = gameData.getInt(\"pokemons\");\r\n        logged_in = gameData.getBoolean(\"is_logged_in\");\r\n        path = gameData.getString(\"graph\");\r\n    }\r\n    private static void setSrcAndDest(Pokemon p) {\r\n        for (node_data n : graphDS.getV()) {\r\n            for (edge_data e : graphDS.getE(n.getKey())) {\r\n                if (isOnEdge(p, e)) {\r\n                    p.setSrc(e.getSrc());\r\n                    p.setDest(e.getDest());\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static boolean isOnEdge(Pokemon p, edge_data e) {\r\n        int srcID = e.getSrc();\r\n        int destID = e.getDest();\r\n        if (p.getType() < 0 && destID > srcID) {\r\n            return false;\r\n        }\r\n        if (p.getType() > 0 && srcID > destID) {\r\n            return false;\r\n        }\r\n\r\n        geo_location srcPos = graphDS.getNode(srcID).getLocation();\r\n        geo_location destPos = graphDS.getNode(destID).getLocation();\r\n        geo_location pokemonPos = p.getPos();\r\n\r\n        return isOnEdge(pokemonPos, srcPos, destPos);\r\n    }\r\n\r\n    private static boolean isOnEdge(geo_location p, geo_location src, geo_location dest) {\r\n        double dist = src.distance(dest);\r\n        double d1 = src.distance(p) + p.distance(dest);\r\n        if (dist > d1 - EPS) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public void setGameNumber(int n) {\r\n        GameNumber = n;\r\n    }\r\n\r\n    public void setID(int id) {\r\n        ID = id;\r\n    }\r\n\r\n    public static Ex2 getEX22() {\r\n        return ex2;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/gameClient/Ex2.java	(revision 5e9ed6921f1aa3f4ecc615620eda9a06c8e010ef)
+++ src/gameClient/Ex2.java	(date 1608414651368)
@@ -1,11 +1,11 @@
 package gameClient;
-
 import Server.Game_Server_Ex2;
 import api.*;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
+
 import javax.sound.sampled.LineUnavailableException;
 import javax.sound.sampled.UnsupportedAudioFileException;
 import javax.swing.*;
@@ -24,12 +24,13 @@
 //            game_thread.start();
 //        }
 //        else {
-//            LoginFrame login = new LoginFrame();
-//            login.setVisible(true);
-            Ex2 ex2 = new Ex2();
-            ex2.setGameNumber(3);
-            Thread game =new Thread(ex2);
-            game.start();
+            LoginFrame login = new LoginFrame();
+            login.setVisible(true);
+//
+//            Ex2 ex2 = new Ex2();
+//            ex2.setGameNumber(3);
+//            Thread game =new Thread(ex2);
+//            game.start();
         //}
     }
     private static final double EPS = 0.000001;
